<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024-03-06 笔试</title>
    <url>/posts/c8a3261c/</url>
    <content><![CDATA[<h3 id="最长连续回文子串"><a href="#最长连续回文子串" class="headerlink" title="最长连续回文子串"></a>最长连续回文子串</h3><p>定义dp数组，dp[i][j]表示字符串i到j是否为回文串。</p>
<p>如果i、j相同，dp[i][j] &#x3D; dp[i+1][j-1]</p>
<p>笔试的时候定义错了，定义成一维，应当注意</p>
<h3 id="最长连续回文子序列"><a href="#最长连续回文子序列" class="headerlink" title="最长连续回文子序列"></a>最长连续回文子序列</h3><p>这个写出来了，定义dp数组，dp[i][j]表示字符串i到j范围内最长回文子序列的长度。</p>
<p>如果i、j相同，dp[i][j] &#x3D; dp[i+1][j-1] + 2</p>
<p>如果i、j不同，dp[i][j] &#x3D; max(dp[i+1][j], dp[i][j-1])</p>
<h3 id="N个男生，N个女生，交叉安排成一个圆环"><a href="#N个男生，N个女生，交叉安排成一个圆环" class="headerlink" title="N个男生，N个女生，交叉安排成一个圆环"></a>N个男生，N个女生，交叉安排成一个圆环</h3><p>其中部分女生不愿意站在某些男生的旁边，如果被安排到了，满意度-1，求满意度的最大值</p>
<p>思路：一个女生只能且必须映射到两个男生中间，采用贪心映射法。对于每个女生，在映射表中找还有没有两个能映射的、且他不讨厌的男生，如果有，则安排成功；如果没有，则满意度减一。</p>
<p>没AC</p>
<h3 id="有效重复字符"><a href="#有效重复字符" class="headerlink" title="有效重复字符"></a>有效重复字符</h3><p>给出类似于 “3a{2{ab}c}” 这样的串，将他展开。数字表示重复次数。</p>
<p>用了栈，遇到’}’就一直弹出字符直到遇到’{‘。然后弹出左括号，继续持续弹出数字。按照数字的次数，重复将这一次弹出的临时字符串再压回栈。最后弹出栈的所有字符</p>
<p>过了80%。感觉重复进栈的操作有点费时间，但是没想到更好的办法。或许可以用双栈。</p>
<h3 id="统计2的次数"><a href="#统计2的次数" class="headerlink" title="统计2的次数"></a>统计2的次数</h3><p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>
<p>示例:</p>
<p>输入: 25<br>输出: 9<br>解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)</p>
<p>分别统计每一位上，数字为2的个数</p>
<p>如果当前位大于2，个数 &#x3D;（当前位的左边部分+1）* 10^当前位的右半部分的长度</p>
<p>如果当前位小于2，个数 &#x3D;（当前位的左边部分）* 10^当前位的右半部分的长度</p>
<p>如果当前位等于2，个数 &#x3D;（当前位的左边部分）* 10^当前位的右半部分的长度+当前位的右半部分+1</p>
<p><font color="red">暴力统计也过了，很无语</font></p>
<h3 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h3><p>一个字符串A可以任意连续字符按照从小到大的顺序排序，判断它是否能排列为另一个字符串S</p>
<p>直接字典序判断A是否大于等于S，过了80%</p>
<p>感觉剩下的数据是在其他地方有问题，笔试的环境很怪异，甚至stack都是我手写的</p>
<h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><ul>
<li>fork()，父进程和子进程不共享虚拟地址空间，继承文件描述符表。fork只是子进程的所有资源、布置都和父进程一样，但是虚拟空间映射到的物理空间仍然是不一样的。</li>
<li>fork之后，父子两个进程同时执行fork函数之后的代码。</li>
<li>文件索引表，指示文件存放物理地址的表。</li>
</ul>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>C++ thread 多线程任务队列</title>
    <url>/posts/f553d691/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="type">int</span> value = <span class="number">1</span>) : <span class="built_in">cnt</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (--cnt &lt; <span class="number">0</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (++cnt &lt;= <span class="number">0</span>)</span><br><span class="line">            cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        max_size = n;</span><br><span class="line">        notfull = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(n);</span><br><span class="line">        notempty = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">        rwlock = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notfull-&gt;<span class="built_in">P</span>(); <span class="comment">// 确保有空位</span></span><br><span class="line">        rwlock-&gt;<span class="built_in">P</span>();  <span class="comment">// 获取互斥锁</span></span><br><span class="line">        q.<span class="built_in">push</span>(e);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程id &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; 执行了add操作，添加数字&quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        rwlock-&gt;<span class="built_in">V</span>();</span><br><span class="line">        notempty-&gt;<span class="built_in">V</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notempty-&gt;<span class="built_in">P</span>();</span><br><span class="line">        rwlock-&gt;<span class="built_in">P</span>();</span><br><span class="line">        <span class="type">int</span> e = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程id &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; 执行了get操作，获取数字&quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        rwlock-&gt;<span class="built_in">V</span>();</span><br><span class="line">        notfull-&gt;<span class="built_in">V</span>();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> max_size;</span><br><span class="line">    Semaphore* notfull, * notempty;</span><br><span class="line">    Semaphore* rwlock; <span class="comment">// 生产者和消费者的互斥锁</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fadd</span><span class="params">(TaskQueue&amp; task_queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> rnd = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        task_queue.<span class="built_in">add</span>(rnd);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fget</span><span class="params">(TaskQueue&amp; task_queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = task_queue.<span class="built_in">get</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TaskQueue <span class="title">task_queue</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">tt1</span><span class="params">(fadd, ref(task_queue))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">tt2</span><span class="params">(fget, ref(task_queue))</span></span>;</span><br><span class="line">    tt1.<span class="built_in">join</span>();</span><br><span class="line">    tt2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用future替代thread，future</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TaskQueue <span class="title">task_queue</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    vector&lt;future&lt;<span class="type">void</span>&gt;&gt; ts;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            future&lt;<span class="type">void</span>&gt; t = std::<span class="built_in">async</span>(fadd, <span class="built_in">ref</span>(task_queue));</span><br><span class="line">            ts.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            future&lt;<span class="type">void</span>&gt; t = std::<span class="built_in">async</span>(fget, <span class="built_in">ref</span>(task_queue));</span><br><span class="line">            ts.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++练习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-04-11-学习</title>
    <url>/posts/f44a7f04/</url>
    <content><![CDATA[<h3 id="objective-C"><a href="#objective-C" class="headerlink" title="objective-C"></a>objective-C</h3><p>objective-C是C语言的超集，属于面向对象的编程语言，但是它有一个比较核心的概念叫Smalltalk，消息传递机制，导致oc和C++的编写方法略有差异。</p>
<ul>
<li>objective-C是C语言的严格超集，所有C语言的程序都可以直接被通过oc编译器，也可以直接使用C语言语法</li>
</ul>
<h4 id="Smalltalk"><a href="#Smalltalk" class="headerlink" title="Smalltalk"></a>Smalltalk</h4><p>Smalltalk是oc的面向对象语法，用法差距和C++对象调用方法很大，与其说是对象调用方法，不如说是对象之间传递消息。<br>举例来说：</p>
<ul>
<li>C++：obj.method(arg1, arg2); 这是对象obj调用method方法</li>
<li>oc：[obj method : arg1, arg2]; 这是发送一个method的消息给obj对象，即使obj没有method方法，程序也能通过编译，在运行期runtime抛出异常。</li>
</ul>
<p>因为运行期才会处理消息，所以可以发送未知消息给对象，即可以很方便实现动态绑定（运行期才决定调用哪个方法）</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>oc当然可以接受C风格字符串，但是通常使用NSString。</p>
<ul>
<li>从常量创建NSString对象：NSString* str &#x3D; @”a string”; 使用‘@’符号标注即可。</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>oc的类声明和C++相似，但看起来差别又很大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface A : NSObject &#123;</span><br><span class="line">    int a; //默认为protected</span><br><span class="line">    @public</span><br><span class="line">        char b;</span><br><span class="line">    @private </span><br><span class="line">        NSString* c;</span><br><span class="line">@property NSString* c; //属性</span><br><span class="line">&#125;</span><br><span class="line">+(int) class_fun1: (int) arg1 andPar: (char) arg2;</span><br><span class="line"></span><br><span class="line">-(void) instance_fun1;</span><br><span class="line">-(char) instance_fun2: (char) arg1;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>大括号里面的是类成员变量，函数方法格式为：</p>
<ul>
<li>+&#x2F;-(返回类型) 函数名称 : (参数类型) 参数名 andPar: …</li>
<li>+表示类级方法，即静态方法，-表示实例方法，即成员方法</li>
<li>@interface和@end标识类的开始和结束</li>
<li>将变量声明为@property属性，可以自动生成getter和setter方法，减少重复代码</li>
</ul>
<h4 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@implementation A : NSObject &#123;</span><br><span class="line">    int d; //默认为private</span><br><span class="line">&#125;</span><br><span class="line">@synthesize c; //这里自动生成getter和setter</span><br><span class="line">+(int) class_fun1: (int) arg1 andPar: (char) arg2 &#123;</span><br><span class="line">    //实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void) instance_fun1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-(char) instance_fun2: (char) arg1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现模块也可以定义变量，默认为private。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>一般的创建对象方法：</p>
<ul>
<li>A *a &#x3D; [[A alloc] init]，init是默认构造函数</li>
<li>上述写法等同于 A *a &#x3D; [A new]，相当于合并调用alloc和init</li>
</ul>
<p>自定义构造方法：</p>
<ul>
<li>格式必须为 -(A) initWith… : (type) arg1 : (type) arg2</li>
<li>调用方法 A *a &#x3D; [[A alloc] initWithXXX : arg1_val arg2 : arg2_val]</li>
<li>多参数方法中，第一个参数的名称默认为方法名，从第二个参数开始为参数名，参数之间空格隔开</li>
</ul>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议类似于Java的接口，就是一组没有实现的方法集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@protocol Sem</span><br><span class="line">-(void) P;</span><br><span class="line">-(void) V;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>声明实现协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface A : NSObject&lt;Sem&gt;</span><br><span class="line">// 声明后，implemention就必须实现P和V方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>




<h3 id="C-迭代器失效"><a href="#C-迭代器失效" class="headerlink" title="C++迭代器失效"></a>C++迭代器失效</h3><p>vector，使用insert或erase之后，之后的元素的迭代器都会失效。容器扩容，所有迭代器都会失效。应当使用insert或erase返回的迭代器。</p>
<p>map，erase后被删除的迭代器失效，因此无法执行++操作，需要在删除前保存下一个迭代器位置。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++智能指针简单造轮子</title>
    <url>/posts/39e4cbdd/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Count</span>(<span class="type">int</span> cnt = <span class="number">1</span>) : _count(cnt)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _count++;</span><br><span class="line">        <span class="keyword">return</span> _count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _count--;</span><br><span class="line">        <span class="keyword">return</span> _count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedPtr</span>(T *ptr = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr = ptr;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _cnt = <span class="keyword">new</span> <span class="built_in">Count</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SharedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr = other._ptr;</span><br><span class="line">        _cnt = other._cnt;</span><br><span class="line">        <span class="keyword">if</span> (_cnt-&gt;<span class="built_in">getCount</span>() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _cnt-&gt;<span class="built_in">add</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SharedPtr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            _ptr = other._ptr;</span><br><span class="line">            _cnt = other._ptr;</span><br><span class="line">            _cnt-&gt;<span class="built_in">add</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _cnt-&gt;<span class="built_in">getCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != <span class="literal">nullptr</span> &amp;&amp; _cnt-&gt;<span class="built_in">minus</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T *_ptr;</span><br><span class="line">    Count *_cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl</span><br><span class="line">         &lt;&lt; p.<span class="built_in">use_count</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SharedPtr&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; endl</span><br><span class="line">             &lt;&lt; q.<span class="built_in">use_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl</span><br><span class="line">         &lt;&lt; p.<span class="built_in">use_count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>NEMU-PA1</title>
    <url>/posts/8a6b2b4c/</url>
    <content><![CDATA[<h3 id="NEMU是什么"><a href="#NEMU是什么" class="headerlink" title="NEMU是什么"></a>NEMU是什么</h3><p><font color="red">个人理解：</font>是NJU编写的一个模拟器，名字来源于<a href="https://zh.wikipedia.org/wiki/QEMU">QEMU（quick emulator)</a>。NEMU运行于GNU&#x2F;Linux操作系统上，用C语言模拟了一个虚拟的计算机系统，包括CPU、内存、IO设备等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                         +---------------------+  +---------------------+</span><br><span class="line">                         |     Super Mario     |  |    &quot;Hello World&quot;    |</span><br><span class="line">                         +---------------------+  +---------------------+</span><br><span class="line">                         |    Simulated NES    |  |      Simulated      |</span><br><span class="line">                         |       hardware      |  |       hardware      |</span><br><span class="line">+---------------------+  +---------------------+  +---------------------+</span><br><span class="line">|    &quot;Hello World&quot;    |  |     NES Emulator    |  |        NEMU         |</span><br><span class="line">+---------------------+  +---------------------+  +---------------------+</span><br><span class="line">|      GNU/Linux      |  |      GNU/Linux      |  |      GNU/Linux      |</span><br><span class="line">+---------------------+  +---------------------+  +---------------------+</span><br><span class="line">|    Real hardware    |  |    Real hardware    |  |    Real hardware    |</span><br><span class="line">+---------------------+  +---------------------+  +---------------------+</span><br><span class="line">          (a)                      (b)                     (c)</span><br></pre></td></tr></table></figure>
<p>图(c)中NEMU和Simulated hardware之间应该还有一层抽象计算机层，描述一个计算机系统需要有哪些硬件和接口。有了抽象计算机层，可以实现<br>多种不同指令架构集的计算机而不改变虚拟机器上层程序的设计形式。</p>
<p>手册给了x86、riscv32和mips32三种指令集选择，选了mips32</p>
<hr>
<h3 id="计算机可以没有寄存器吗"><a href="#计算机可以没有寄存器吗" class="headerlink" title="计算机可以没有寄存器吗"></a>计算机可以没有寄存器吗</h3><h4 id="回答这个问题之前先看看MIPS32手册"><a href="#回答这个问题之前先看看MIPS32手册" class="headerlink" title="回答这个问题之前先看看MIPS32手册"></a>回答这个问题之前先看看MIPS32手册</h4><ol>
<li>MIPS32架构定义了CPU寄存器和FPU寄存器：<ul>
<li>CPU寄存器包括r0 ~ r31，共32个通用寄存器；Program Counter；HI&#x2F;LO（存放乘除指令结果）。r0可以代表默认0，r31在 <strong>JAL, BLTZAL, BLTZALL, BGEZAL, BGEZALL</strong> 指令中表示默认目标地址。</li>
<li>FPU寄存器包括32个通用寄存器，存放单精度浮点数；5个控制寄存器（暂时不清楚用法）。</li>
</ul>
</li>
<li>MIPS32默认是小端序</li>
<li>对齐策略：<ul>
<li>半字（2 byte）数据要对齐0，2，4…</li>
<li>字数据（4 byte）数据对齐0，4，8…</li>
<li>双字数据（8 byte）数据对齐0，8，16…</li>
</ul>
</li>
</ol>
<h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>计算机的寄存器用于暂存数据和指令，如果没有寄存器，那就需要其他介质作为替代，比如内存。如果没有内存，也可以是外部指令流输入控制计算机运行，但是为了暂存中间结果，始终需要有一个存储器模块。</p>
<p>MIPS手册描述了编程模型的6个方面：</p>
<ul>
<li>CPU数据形式：<ul>
<li>bit</li>
<li>字节</li>
<li>半字</li>
<li>字</li>
<li>双字</li>
</ul>
</li>
<li>协处理器<ul>
<li>CP0：用于虚拟地址转换、异常处理、核心调度、控制cache系统、故障恢复等</li>
<li>CP1：保留用于浮点处理器FPU</li>
<li>CP2：作特殊用途</li>
<li>CP3：保留用于MIPS64架构</li>
</ul>
</li>
<li>CPU寄存器有哪些</li>
<li>FPU数据形式<ul>
<li>32位单精度浮点数</li>
<li>32位单精度浮点数 paired-single（没理解意思）</li>
<li>64位双精度浮点数</li>
<li>32位定点字</li>
<li>64位顶点字</li>
</ul>
</li>
<li>字节序和大小端</li>
<li>内存访问类型</li>
</ul>
<p>如果不存在寄存器，CPU的数据处理形式并不受影响，协处理器工作不受影响，CPU中的程序计数器PC功能需要由其他硬件支持，通用寄存器暂存功能需要由其他硬件支持，FPU的数据处理形式不受影响，字节序和大小端仍然需要定义，内存访问类型仍然需要定义。</p>
<h3 id="从状态机视角理解程序运行"><a href="#从状态机视角理解程序运行" class="headerlink" title="从状态机视角理解程序运行"></a>从状态机视角理解程序运行</h3><p><img src="/posts/8a6b2b4c/1.jpg" alt="pa1"><br>图灵机的基础：当前状态+当前输入 -&gt; 状态转移 -&gt; 下一状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// PC: instruction    | // label: statement</span><br><span class="line">0: mov  r1, 0         |  pc0: r1 = 0;</span><br><span class="line">1: mov  r2, 0         |  pc1: r2 = 0;</span><br><span class="line">2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;</span><br><span class="line">3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;</span><br><span class="line">4: blt  r2, 100, 2    |  pc4: if (r2 &lt; 100) goto pc2;   // branch if less than</span><br><span class="line">5: jmp 5              |  pc5: goto pc5;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(PC, r1, r2) : (0, x, x) -&gt; (1, 0, x) -&gt; (2, 0, 0) -&gt; (3, 0, 1)</span><br><span class="line">-&gt; (4, 1, 1) -&gt; (2, 1, 1) -&gt; (3, 1, 2) -&gt; (4, 3, 2) -&gt; (2, 3, 2)</span><br><span class="line">-&gt; (3, 3, 3) -&gt; (4, 6, 3) -&gt; (2, 6, 3) -&gt; ... -&gt; (4, 4851, 99) </span><br><span class="line">-&gt; (2, 4950, 99) -&gt; (3, 4950, 100) -&gt; (4, 5050, 100) </span><br><span class="line">-&gt; (5, 5050, 100) (end)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ICS实验</tag>
      </tags>
  </entry>
  <entry>
    <title>2024/2/21-笔试</title>
    <url>/posts/4a67726/</url>
    <content><![CDATA[<h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p>MySQL分布式事务：XA事务，2pc。将分布式事务执行的过程分为两阶段，第一阶段所有需要执行操作的节点准备自身资源数据，检查是否可以提交，向事务管理节点发送precommit的消息。所有节点都准备就绪precommit后，才能开始实际执行事务，期间等待是阻塞的。</p>
<p>Java垃圾回收：强引用，任何时候都不回收；软引用，空间不足时回收；弱引用和虚引用，任何时候都回收。</p>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h4 id="第一题忘了，比较简单"><a href="#第一题忘了，比较简单" class="headerlink" title="第一题忘了，比较简单"></a>第一题忘了，比较简单</h4><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>第二题题意是，一个数组中，任选两个元素删除，并将它们的和再加入数组，使数组的极差最小。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>用优先队列读入元素，删除最小的两个元素，再加入数组。过了90%。</p>
<p>忘记考虑的点：最小的两个元素相加后，可能大于原数组最大的元素，而我直接默认优先队列头的元素最大了，测试数据中可能出现了负数。</p>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>n个杯子中有k杯水，每个回合可能的行为：</p>
<ul>
<li>随机选择一个杯子</li>
<li>如果杯子空：则回合结束</li>
<li>如果杯子不空：上回合喝过水了，则放下杯子回合结束；上回合没喝水，则喝掉杯子里的水</li>
</ul>
<p>最终求所有水被喝完时的回合数的期望值。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>很明显是一个数学题。假如不考虑两次喝水之间的间隙，还剩i杯水的时候，喝到水的概率p&#x3D;i&#x2F;n。此时，喝一杯水的期望回合是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T = p*1 + p(1-p)*2 + p(1-p)^2*3 + ... + p(1-p)^n*(n+1)</span><br><span class="line">  = i/n(1-p)^2</span><br></pre></td></tr></table></figure>
<p>然后令i&#x3D;k，i&#x3D;k-1, … i&#x3D;1，累加即可</p>
<p>没想出来的地方：两次喝水有间隙——卡在这里很久，实际上只需要在最后的结果加上k-1个回合就可以了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-03-01-oppo一面</title>
    <url>/posts/e8b72eb/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>2月29日上午邮件通知面试，3月1日下午14:10开始，调试设备约5分钟，面试时长约30分钟，无手撕代码。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><strong>自我介绍</strong>：主要介绍了我的本科、硕士经历，常用编程语言，业余项目。</li>
<li><strong>个人介绍中提到了论文，介绍论文工作和贡献</strong>：主要从研究背景、解决方法、创新点三方面讲了一下。</li>
<li><strong>论文中怎麽判断用户是否恶意，用哪些属性</strong>：我理解的意思是，怎么筛选重要属性和非重要属性。主要根据过往文献总结、个人经验，筛选出“粉丝、关注、博客数、是否开启定位、是否开启账号保护”这几项属性为比较重要的。</li>
<li><strong>C++的内存管理</strong>：new和delete、智能指针</li>
<li><strong>深入讲一下new</strong>：new主要做三部分工作，计算对象大小、在堆上开辟空间，调用类构造函数，将对象绑定到开辟空间的地址上（返回指针）</li>
<li><strong>多线程编程了解哪些</strong>：用C++写过一个生产者消费者程序，用mutex、条件变量、int类型的资源标记数定义了信号量的P、V操作，用于临界资源管理。对C++的队列容器进行了包装，用三个信号量分别用于标志队列未满、队列未空以及当前是否有线程访问队列。</li>
<li><strong>用的什么队列</strong>：猜测是联想到了Java中队列有很多种实现形式，说明了用的就是C++中的默认队列。<font color="red">这里回答有一点错误，C++的queue是一个容器适配器，类似于Java中的接口，默认实现方式其实是deque。</font>之后我也讲了一下deque的底层，是多块不连续内存加一个数组实现的。以及优先队列是堆。</li>
<li><strong>介绍最有价值的项目</strong>：其实都是业余项目，简单讲了一下QQ聊天机器人的架构。Nonebot+Gocqhttp，Nonebot是Onebot协议的实现，类似于一个Python的SDK。Gocqhttp通俗来说是模拟QQ客户端的一个程序，与腾讯的消息服务器通信。我做的是Nonebot框架下的功能插件开发，包括点歌、记账、定时提醒等。顺便讲了一下消息传递的优先级模式。</li>
<li><strong>反问</strong>：<ul>
<li>研发有很多方向，具体是由谁定？——主要看个人兴趣</li>
<li>Java了解比较浅，有没有关系？——有导师带，当然自己尽快学习上手最好</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试官人很好，基本是顺着我的舒适区提问，让我有点不好意思。因为没有手撕环节，整体流程体感比较快。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ的存储空间为什么会越来越大</title>
    <url>/posts/cda2b7f1/</url>
    <content><![CDATA[<h3 id="注意到问题的缘由"><a href="#注意到问题的缘由" class="headerlink" title="注意到问题的缘由"></a>注意到问题的缘由</h3><p>我有定期清理硬盘空间的习惯，除了用dism++清理系统临时文件以外，还会手动去检查一些占用空间比较大的文件夹。</p>
<p>事情就发生在上一次清理空间的时候。我习惯性地打开QQ存储文件主目录，然后删除 QQ&#x2F;&lt;qq号&gt;&#x2F;Image&#x2F;Gourp2 里的所有文件。关于这里，还有一点想吐槽的：</p>
<ul>
<li>QQ为了加速图片检索，以Gourp2文件夹为根建了一颗B+树，所以点开文件夹会看到很多个名称长度为2的子文件夹，子文件夹下又有若干个名称长度为2的子文件夹，里面存储的就是文件前缀名相同的几张图片。结果就是删除的时候系统会做很多额外的检查，比如找文件索引、检查权限等等，因为删除实际上也是文件的移动，移动到回收站而已，整个删除过程速度非常慢。</li>
</ul>
<p>回到主题，删除完没用的群聊图片后，我发现QQ占用空间仍然很大，而且点击文件夹属性，存储空间计算时有一个断崖式的增长，也就是肯定存在一个大文件，进而才发现了 Msg3.0.db 和 Msg3.0index.db</p>
<h3 id="Msg3-0-db"><a href="#Msg3-0-db" class="headerlink" title="Msg3.0.db"></a>Msg3.0.db</h3><p>Msg3.0.db 和 Msg3.0index.db 在我的电脑上一个占用11.3GB，一个占用7GB。</p>
<p>根据文件名形式，猜测是SQLite，网上查了一下确实是。所以说QQ是将所有的聊天记录都存储在 Msg3.0.db 中，并且为其建立了 Msg3.0index.db 的索引。</p>
<p>在QQ界面有一个消息管理器，所有消息记录都存储在 Msg3.0.db 中。如果不删除，那QQ占用空间就确实会随着时间越来越大，只删除图片缓存也没用。</p>
<p>删除的时候，文件夹下会有相应的 db-journal 文件，实际上就是事务执行时的临时文件，用于回滚。事务执行结束后会清空为0字节，但不会删除，省去下次创建操作。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>SRS直播服务器</title>
    <url>/posts/1fa37b1/</url>
    <content><![CDATA[<h3 id="使用SRS-Stack构建"><a href="#使用SRS-Stack构建" class="headerlink" title="使用SRS-Stack构建"></a>使用SRS-Stack构建</h3><p>腾讯云轻量应用服务器提供了应用模板，在控制台重装为音视频流服务器即可快速启动SRS服务。</p>
<h3 id="使用Docker构建"><a href="#使用Docker构建" class="headerlink" title="使用Docker构建"></a>使用Docker构建</h3><p>SRS文档提供了服务启动脚本，在服务器中安装好docker后运行即可。</p>
<h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><ol>
<li>docker hub配置镜像源，配置文件为&#x2F;etc&#x2F;docker&#x2F;daemon.json</li>
<li>在腾讯云控制台开放1935、8080、8000端口，用于推流和访问直播服务器管理后台</li>
<li>docker默认的推流地址是rmtp:&#x2F;&#x2F;host&#x2F;live，推流码是livestream</li>
</ol>
<h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ul>
<li>默认推流方式需要观看者安装VLC等能接收rmtp流的播放器</li>
<li>SRS提供的网页端流播放器在url中明文携带参数内容，url很长，且容易暴露信息</li>
<li>域名备案很麻烦，暂时搁置。备案不了域名就无法使用WebRTC-HTTPS。不管是访问后台还是观众观看都是不安全的IP地址访问</li>
<li>服务器带宽限制，直播很卡，只能用OKANE解决的问题</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Samsung S24+使用体验</title>
    <url>/posts/70749ec9/</url>
    <content><![CDATA[<h3 id="高中毕业前"><a href="#高中毕业前" class="headerlink" title="高中毕业前"></a>高中毕业前</h3><p>高中毕业之前，我用的手机一直是家里淘汰下来的旧手机，前前后后用过诺基亚经典九键、三星（很老的一款）、oppo、iPhone 5S。</p>
<h4 id="01"><a href="#01" class="headerlink" title="01"></a>01</h4><p>诺基亚是第一款手机，大概是小学毕业前后开始用的，基本上只能聊QQ。</p>
<h4 id="02"><a href="#02" class="headerlink" title="02"></a>02</h4><p>初二的时候，买了iPad 2，同时也换了第一款智能手机。具体型号已经记不清了，大概是三星S或者Note系列的初代&#x2F;二代。刚开始用的时候还行，但流畅度随着时间稳定下降，打开APP速度也骤降。最夸张的是，重启一次手机后，打开QQ居然会花费接近1分钟的时间。</p>
<h4 id="03"><a href="#03" class="headerlink" title="03"></a>03</h4><p>oppo是家里人淘汰下来的旧手机，虽然是旧款，但流畅度显然比上一款三星好了很多，直到换iPhone 5S之前都没有遇到卡顿问题。最大的问题是电池续航，虽然当年的电池容量还没有现在这么大，但开机后1分钟掉10%的电量也非常夸张。当时是高中时期，每周日下午三点充满电，到学校六点交手机关机，到下周的周六下午四点拿到手机，回到家大约五点。仅仅是这四个小时都难以支撑下来。</p>
<h4 id="04"><a href="#04" class="headerlink" title="04"></a>04</h4><p>iPhone 5S也是家里人淘汰下来的旧手机，不过是我主动提出要换的，原因就是电池续航问题。在当时，5S的流畅度和续航能力都完全满足我的需求，唯一的问题在于iOS系统封闭，无法便捷使用一些开源APP。</p>
<h3 id="大学期间"><a href="#大学期间" class="headerlink" title="大学期间"></a>大学期间</h3><p>大学期间使用的手机是在天津买的，当时荣耀和华为还同属一家，买的是荣耀9，在当时属于性价比很高的中端手机。</p>
<h4 id="荣耀9"><a href="#荣耀9" class="headerlink" title="荣耀9"></a>荣耀9</h4><p>荣耀9从大一用到大四下学期，差不多3年半，使用体验如下：</p>
<ul>
<li><strong>系统</strong>：EMUI。拥有大量我从未使用过的本地化和便捷功能，虽然当时没什么感觉，但对于现在来说，这些冗余的推送、新闻、卡片服务是无法忍受的。</li>
<li><strong>指纹解锁</strong>：有Home键，解锁速度傻快，比后来用的Redmi还快，但手不干净时还是会失灵。</li>
<li><strong>运存</strong>：4GB。我会随时清理后台，所以对于运存大小不是很敏感。</li>
<li><strong>闪存</strong>：没记错的话是64GB。闪存都是，刚开始够用，随着时间推移就不够用了，到后来必须隔一段时间清除微信和QQ的全部数据。</li>
<li><strong>GMS</strong>：没有禁用，但想要使用也比较费劲，需要手动安装框架、下载play store，且play store无法自动版本更新，基本属于阉割版。</li>
<li><strong>推送服务</strong>：当时没怎么注意，但想必当时用的也是华为的统一推送服务，基本的QQ和微信消息都有及时推送，也有一些广告推送。印象中没有fcm的推送。</li>
<li><strong>摄像</strong>：完全没注意过，扫码水平。</li>
<li><strong>硬件</strong>：主要指屏幕。基本告别需要低延迟触控的音乐游戏。</li>
</ul>
<p><strong>总结</strong>：第一款自主选购的智能手机，在本人的电子洁癖症还不太严重的时候，基本满足了所有需求。但最终让我无法忍受、不得不换手机的原因主要是：**<font color="red">电池、闪存</font>**。</p>
<p>简单来说就是续航崩坏，闪存爆满。</p>
<h4 id="红米Redmi-K30U"><a href="#红米Redmi-K30U" class="headerlink" title="红米Redmi K30U"></a>红米Redmi K30U</h4><p>红米是在大四下学期换的，第一批5G进网试用的机器，差不多用了三年，使用体验如下：</p>
<ul>
<li><strong>系统</strong>：MIUI。拥有大量本地化和便捷功能，使用过一部分，例如万能遥控、地震预警，但系统中仍然存在不少无法卸载的自带APP和功能，虽然可以通过权限完全禁用，但无法隐藏其图标，仍然会带来一定程度的折磨。</li>
<li><strong>指纹解锁</strong>：光感屏下指纹。在强光环境下非常难用，例如大白天走在外面，需要用左手遮住光才能正常解锁，解锁速度也很慢，完全不及荣耀9。</li>
<li><strong>运存</strong>：8+3GB，应该是用闪存换的虚拟内存。没什么实感，因为我随时清后台。</li>
<li><strong>闪存</strong>：128GB。当初以为完全够用的，结果空间越来越少，从占用50GB一路飙升到现在的100GB，而且QQ和微信的空间也有随时清理。</li>
<li><strong>GMS</strong>：没有禁用，相比荣耀9来说使用更方便了一些，但仍然需要手动安装play store，并且无法自动更新商店版本。</li>
<li><strong>推送服务</strong>：mi push。推送非常及时，除了常用的QQ和微信，甚至能及时推送AcFun主播开始直播的消息。但相应的，也会收到很多不想收到的消息，比如支付宝、携程旅行、12306的推广消息。推送消息虽然可以分类别开关，但每个类别的描述非常模糊，很难理解哪些消息属于哪些类别，为了不错过某些消息，比如包裹物流，只能开启全类别推送。此外，默认能够连接到fcm服务，但系统会默认关闭所有APP的自启动权限和后台运行权限，因此fcm在默认状态下是无法工作的。想要及时收到gmail等应用的消息，必须手动开启自启动权限，取消后台运行限制等。</li>
<li><strong>摄像</strong>：外星科技升降前置摄像头，提供了一块完整、没有挖孔、没有刘海的全面屏。拍照质量不提，速度有些慢，估计是校正算法太耗时。</li>
<li><strong>硬件</strong>：主要指屏幕。亮度一般，反光严重，基本告别音乐游戏。</li>
</ul>
<p><strong>总结</strong>：当初购买这款手机也纠结了很久，最后选择原因主要是性价比和系统开放度。到手后我研究了很久刷机，先是注册账号等一周，然后找固件，最后发现K30U是国行特供，没有国际版固件，因此告别了刷机。总体来说，前半段时间使用体感良好，后半段时间问题越来越多，包括：</p>
<ul>
<li><strong>续航</strong>：4500mA的电池，没有防过充，长期的过饱和充电把电池损得需要一天两充甚至三充，出门80%电量都心慌还要带充电宝。</li>
<li><strong>指纹</strong>：如上所述，在外使用非常不便。</li>
<li><strong>WiFi信号</strong>：长期以来，我一直以为在宿舍连不上校园网是宿舍的问题，直到我换了手机才发现是小米的问题。</li>
<li><strong>闪存</strong>：128G已经无法满足一众庞然大物APP了。</li>
</ul>
<h3 id="三星S24"><a href="#三星S24" class="headerlink" title="三星S24+"></a>三星S24+</h3><p>终于到了主题。考虑换手机是在2024年1月份的时候，因为实在无法忍受出门必备充电宝，考虑换一个电池容量更大的手机。</p>
<p>最开始考虑的需求是：</p>
<ul>
<li>电池容量大</li>
<li>闪存大</li>
<li>广告少</li>
<li>能比较方便地刷机</li>
<li>最好不是挖孔屏</li>
</ul>
<p>在上述考虑下，选择了如下几款机型：</p>
<ul>
<li>小米14</li>
<li>一加12</li>
<li>一加Ace3</li>
<li>努比亚z60</li>
</ul>
<p>但最后被一一排除：</p>
<ul>
<li>小米14是澎湃OS，几乎不可能达到解锁系统的要求</li>
<li>努比亚z60太重，几乎是带个板砖出门</li>
<li>一加12和一加Ace3其实蛮无辜的，去线下看实机之前，顺带去逛了一下三星旗舰店，摸了一下S24新机，然后再摸一加12的曲面屏，瞬间感觉无法接受。此外，ColorOS系统似乎也不太干净，不太适合有高度电子洁癖的我。与此同时，三星S24就成为了我选购的目标。</li>
</ul>
<h4 id="调校和设置"><a href="#调校和设置" class="headerlink" title="调校和设置"></a>调校和设置</h4><p>到手后首先是转移数据，联系人、短信、照片等数据都是用腾讯的换机助手转移的，S换机助手貌似不能在不同品牌手机之间转移数据。</p>
<p>然后是下载应用，调校设置。应用通知权限、电池使用策略、屏幕布局、UI美化等等。不得不说，ONE UI的功能真的很多，但也藏得真的很深，许多设置搜都搜不出来，例如：</p>
<ul>
<li>锁屏界面的布局设置，需要在锁屏界面长按才能进去，其他地方完全搜索不到。如果设置了人脸自动解锁，根本就很难进入到设置界面，非常反人类。</li>
<li><strong>消息通知设置</strong>：可谓是花费我心力最多的一项设置。最开始，我的目标是做成iOS通知那样，有消息来自动亮屏，消息在锁屏界面堆叠式陈列。<ul>
<li>第一个尝试的解决方案是息屏提醒，设置有消息来时开启息屏。但息屏和锁屏始终不是同一个东西，亮屏只能让你知道有消息了，但息屏界面不会显示具体的消息栏，只有一个很小的图标，几乎没有任何标识作用。此外，息屏亮之后要很长时间才会黑屏，对于强迫症来说，超过2秒都是极限了啊。</li>
<li>第二个尝试的，也是目前使用的解决方案，将消息提醒设置为【简洁】，（没错，如果设置为详细内容，是没有办法弹窗的），然后允许弹窗提示，这样即使是黑屏界面，消息弹窗依然会正常显示，并且只会存在1秒左右，基本起到了提醒作用。此外，也可以附加锁屏特效，不过我不太喜欢。</li>
<li>虽然最终没有达到iOS的消息通知效果，不过目前的方案也还算满意。黑屏状态下，有消息会弹窗显示，虽然不会亮屏，但双击也可以进入锁屏界面查看消息概要。</li>
</ul>
</li>
</ul>
<h5 id="电池优化策略"><a href="#电池优化策略" class="headerlink" title="电池优化策略"></a>电池优化策略</h5><p>三星的电池优化策略可以按应用设置，分为无限制、优化和受限制。国行机器默认是全受限制，其他版本固件默认是全优化。</p>
<ul>
<li>受限制：应用在后台运行一段时间后会自动结束，即使内存足够也不会保活，具体的存活时间未知。曾经用听歌软件测试，听了一段时间后音乐确实突然就停止了，打开应用发现已经重启了。（此外，由于三星的推送服务接入的应用很少，大多数应用发送消息都不得不依赖后台，所以受限制的应用通常也没法在关闭的状态下推送消息）。</li>
<li>优化：优化策略未知，使用体验约等于无限制。由于我后台不会留存太多应用，所以设置为优化的APP基本没有被杀后台的情况。（如果想使用fcm服务接受推送，也需要将对应的应用设置为优化及以上的策略）。</li>
<li>无限制：可以无限制运行、自启动，但内存不足时是否会杀后台未知。</li>
</ul>
<p>根据我个人的使用习惯，QQ和微信为无限制，邮件APP、听歌软件为优化，其他APP基本都为受限制，不影响使用，也基本收不到广告消息。</p>
<h5 id="指纹解锁和面部解锁"><a href="#指纹解锁和面部解锁" class="headerlink" title="指纹解锁和面部解锁"></a>指纹解锁和面部解锁</h5><p>指纹解锁应该是超声波类型的，没有像上一部机器一样遇到强光就无法解锁的情况。黑屏状态下没有指纹图标，但可识别区域较大，允许一定的误差，解锁速度非常快，傻快。</p>
<p>面部解锁。其实最开始不太想用的，但在手不方便的时候面部解锁看消息实在太方便了，所以还是开启了。黑暗环境、戴口罩无法识别，其余情况识别速度也很快。设置中可以更改识别面部后立刻解锁，或是停留在锁屏界面，我是习惯停留在锁屏界面，可以看看消息就关。</p>
<h5 id="固件-刷机"><a href="#固件-刷机" class="headerlink" title="固件 &#x2F; 刷机"></a>固件 &#x2F; 刷机</h5><p>为了体验Google系AI的功能，我在调校好手机一周后毅然又刷了港版固件。解锁无需前置条件，刷机也非常简单，下载好文件后十来分钟就可以刷完。</p>
<p>体验下来，相比于国行，港版固件系统自带的系统服务组件、Google服务组件更多，省电策略也比较粗放，可以明显感觉电量用得更快。至于AI功能，我发现不管是哪个版本我都不会主动去使用，用了两天后又刷回了国行，没出现任何问题。</p>
<h5 id="S换机助手"><a href="#S换机助手" class="headerlink" title="S换机助手"></a>S换机助手</h5><p>在刷固件的时候，用到了S换机助手，可以将手机备份到电脑。数据基本上能把手机完全还原到备份时的状态，包括相册分类、各种设置等等，只有QQ、微信、支付宝等应用的登录数据会消失。</p>
<h5 id="其他非常方便、但需要自行调校的功能"><a href="#其他非常方便、但需要自行调校的功能" class="headerlink" title="其他非常方便、但需要自行调校的功能"></a>其他非常方便、但需要自行调校的功能</h5><ul>
<li>三星钱包。可以在钱包中加入支付宝、微信的付款码，公交地铁乘车码等等。设置黑屏状态下从屏幕底部向上扫，可以快速打开钱包，再也不需要在排队的时候提前打开支付宝或微信了。</li>
<li>模式和日常程序。目前我设置了如下：<ul>
<li>睡眠模式：开启飞行模式、黑暗模式、免打扰模式、灰度。</li>
<li>连接到WiFi自动关闭流量：WiFi断开后也会自动开启流量。</li>
<li>打开美团、百度地图自动开启定位：关闭后会自动关闭定位</li>
</ul>
</li>
</ul>
<p>这些日常中经常会用到的“组合技”，用了才知道有多方便。</p>
<h5 id="目前用着不太方便的地方"><a href="#目前用着不太方便的地方" class="headerlink" title="目前用着不太方便的地方"></a>目前用着不太方便的地方</h5><ul>
<li>短信通知需要展开才能点击已阅读。</li>
<li>邮件经常会通知两次。</li>
<li>相册文件夹可以分类，但在其他地方调用相册时无法分类，找相册很麻烦。（感觉绝大部分手机也没法解决这个问题）</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>系统</strong>：ONE UI。一款简洁又复杂的系统，如果没有功夫钻研设置，系统用起来会相当不方便（比如最开始的通知就花了很长时间设置），但设置好后，会真正感觉到手机服务于人，而不是人适应手机。</li>
<li><strong>指纹解锁</strong>：声波指纹。傻快，超越前面用过的所有手机。</li>
<li><strong>运存</strong>：12GB。很多人觉得16GB才是当代旗舰该有的基本配置，不过我常清后台感觉不到。</li>
<li><strong>闪存</strong>：512GB。先行者预约，可以256GB升到512GB，目前完全没有存储空间焦虑。</li>
<li><strong>GMS</strong>：使用起来和小米差不多，需要手动安装Play Store。</li>
<li><strong>推送服务</strong>：三星push几乎不会有任何作用，只会偶尔推送一些系统提示。QQ和微信的消息推送完全靠无限制后台，其他邮件等推送完全靠自行设置的fcm。另外，正常使用fcm也花费了我不少功夫，并且国行锁定了*#<em>#426#</em>#*查看fcm log，所以还需要第三方APP提供入口。事实上，大多数地区都是能够直连到mtalk.google的，我当时的问题大概率出在DNS设置上。对于喜欢简洁的我来说，短信、QQ、微信、邮件推送已经足够了。</li>
<li><strong>摄像</strong>：目前用过的摄像最好的手机，成像速度也很快。前置摄像头挖孔，但只能和解了。</li>
<li><strong>硬件</strong>：屏幕傻亮，太阳底下最大亮度基本都看的清。直屏手感舒适，用原厂膜的话，反光也会降到很低。</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>应该是目前使用过最满意的手机，让我对三星这个品牌有所改观。同时也真正体会到了手机的便捷之处。不出意外的话，未来还会换三星S系列。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>关于FCM服务的一些问题</title>
    <url>/posts/24b990d7/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>昨天晚上，突然发现QQ邮箱app即使允许电池无限制使用，收到邮件的时候也不会推送通知，查了一下是因为三星没有像mipush一样的推送服务，QQ邮箱只有常驻后台运行才能通知。</p>
<p>于是为了能及时收到信息，我下载了支持fcm的gmail和outlook，测试能不能利用fcm推送</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><ol>
<li><strong>电池优化问题</strong><ul>
<li>国行安卓手机没有统一的推送服务，大多只能靠应用后台保活来实现实时通知，比如QQ和微信就是默认无限制运行，允许任意自启动和重启，所以才能随时收到消息。</li>
<li>经过排查，所有支持fcm的应用都设置了无限制运行，允许常驻，仍然无法收到通知</li>
</ul>
</li>
<li><strong>FCM问题</strong><ul>
<li>允许应用自启动，但是没有收到消息，说明outlook和gmail并没有收到来自FCM的通知，遂检查FCM连接状况。</li>
<li>三星国行禁用了<font color="red">*#*#426#*#*</font>查看fcm连接状况，只能通过第三方app进入诊断页面。我在github找到了一个FCM推送查看器。在log里可以看到，FCM服务是断开的，每隔十几分钟会尝试重连，然后连接失败，log为<code>Connecting using McsConnection&#123;NetworkWrapper&#123;244&#125;,type=0,isVpnConnected=true&#125;</code></li>
<li>看到这个log，我以为是clash的问题，于是关闭代理再次连接，成功连接上。所以这里我以为是fcm服务，也就是mtalk.google会检测代理连接，必须直连，所以花了很长一段时间想在配置文件里加上混合配置或者parser。但问题在于，我另一个手机使用相同的配置，能够长期稳定连接到fcm服务不断开，所以问题根源不在这里。</li>
</ul>
</li>
<li><strong>DNS问题</strong><ul>
<li>绕了很长一段远路，最后想起来clash有日志捕捉功能，遂开启。很快找到原因，<code>error: all DNS requests failed, first error: use default dns resolve failed: all DNS requests failed, first error</code>。所以是DNS问题，尝试了三个解决手段：<ul>
<li>关闭clash中的DNS劫持：无效</li>
<li>WIFI设置手动DNS：无效</li>
<li>clash中设置强制启用系统hosts和DNS：有效</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>所以根本上是clash配置文件中的DNS server有一些问题。但还有一点不明白的地方：在测试连接的时候，我发现只有 <font color="red">5G网络+开启代理</font> 两者组合会导致DNS出现问题。使用2.4GHZ的WIFI或者4G移动数据+代理，可以连接。使用5GHZ的WIFI或者5G移动数据，可以连接。但5G+代理，不修改DNS设置就会出现问题，这一点仍然摸不着头脑。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>后端面试</title>
    <url>/posts/631ff09e/</url>
    <content><![CDATA[<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>面试了大约1个小时，面试官对于每个回答的问题会及时给出反馈，还会提一些建议，人很好，挂了我也值了。</p>
<ul>
<li>MySQL，多了解一些锁相关的知识。比如什么查询会锁表之类的</li>
<li>存储引擎，除了InnoDB再了解一些别的</li>
<li>三次握手和四次挥手，几个状态，从来没记过，现在还债了</li>
<li>Linux命令，查看网络端口<ul>
<li>lsof -i [端口号] 查看端口占用</li>
<li>netstat -tunlp | grep 端口号，列出tcp&#x2F;udp连接，然后过滤查看端口号</li>
</ul>
</li>
<li>布隆过滤器的用处：<ul>
<li>数据库，避免缓存穿透</li>
<li>做黑名单</li>
</ul>
</li>
</ul>
<p><strong>面试的时候有些东西我讲得比较啰嗦，比如缓存穿透那里，可以更简洁一些</strong></p>
<p>非常不错的面试体验，必须再重申挂了我也值了</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>NEMU-pa0</title>
    <url>/posts/50a57998/</url>
    <content><![CDATA[<p>主要问题有</p>
<ul>
<li>虚拟机网络问题</li>
<li>github TLS问题</li>
</ul>
<h3 id="虚拟机网络"><a href="#虚拟机网络" class="headerlink" title="虚拟机网络"></a>虚拟机网络</h3><p>因为我主机用了代理，允许局域网连接。<br>想要使用主机的网络，使用的是桥接模式，复制主机的网络状态，<br>相当于虚拟机加入到了主机同一个局域网中，可以互相ping到。<br>然后系统代理选择主机的IP和相应端口，所有流量都先转发给主机做处理，<br>主机有点像一个默认“网关”？</p>
<hr>
<p><font color="red">2023&#x2F;12&#x2F;15 update</font></p>
<p>用桥接模式有一点问题，就是主机的IP是变化的，相应的代理都要手动变更。</p>
<p>NAT模式是虚拟了一个Vmnet交换机，交换机上连接了虚拟NAT设备、虚拟DHCP服务器和虚拟机。虚拟机通过虚拟交换机、虚拟NAT和外部主机网关连接，实现联网。另有一个虚拟网卡，实现主机和虚拟机的通信。虚拟网卡的地址是相对固定的，所以代理地址只要填虚拟网卡的地址即可。<br></p>
<h3 id="github-TLS问题"><a href="#github-TLS问题" class="headerlink" title="github TLS问题"></a>github TLS问题</h3><p>git clone、push的时候，会出现TLS connection不安全的问题。</p>
<p>主要解决方法是，以自己的github账号为KEY，生成一对RSA密钥，用于SSH连接<a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#109;</a>。</p>
<p>本机ssh-keygen -t rsa -C “xxx”之后，将公钥添加到github账号，相当于免密登录</p>
<p>然后git clone和git push时要使用<a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>&#x2F;仓库地址，而不是http或https</p>
<h3 id="顺便记录一个最简单的Makefile"><a href="#顺便记录一个最简单的Makefile" class="headerlink" title="顺便记录一个最简单的Makefile"></a>顺便记录一个最简单的Makefile</h3><p>hello:<br>    gcc hello.cpp -o hello</p>
<p>以后再学</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ICS实验</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识复习笔记3-I/O多路复用</title>
    <url>/posts/830442ea/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前看图解计算机基础知识的时候，看过几次I&#x2F;O多路复用的内容，但感觉都没有抓到本质。面试的时候也被问过几次，回答得也不太好。所以重新梳理一下个人理解。</p>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>I&#x2F;O就是输入输出，计算机的存储器（内存）和周边设备的数据传输，最主要的就是文件读取&#x2F;写入。网络传输也是I&#x2F;O的一部分，Linux中一切皆文件，网络编程用到的socket也是一个文件描述符。</p>
<h4 id="单个进程的文件读取"><a href="#单个进程的文件读取" class="headerlink" title="单个进程的文件读取"></a>单个进程的文件读取</h4><ul>
<li>文件管理是由操作系统完成的，所以实际的文件数据读取和传输需要切换到内核态。</li>
<li>相较于内存，外存的文件读取是相当慢的。因此CPU不会白白浪费时间等待，而是会阻塞等待I&#x2F;O的进程，切换去运行其他进程。直到数据传输准备完毕，内核唤醒等待进程，再继续运行。</li>
<li>用户态的进程，需要有一个内核态的进程维护其状态。</li>
</ul>
<h4 id="多个进程的文件读取"><a href="#多个进程的文件读取" class="headerlink" title="多个进程的文件读取"></a>多个进程的文件读取</h4><ul>
<li>为每一个进程的I&#x2F;O流创建一个进程&#x2F;线程维护其状态。当并发量很大时，系统资源吃不消。</li>
</ul>
<h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h4><p>用一个进程维护多个I&#x2F;O连接（网络连接）</p>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>用户态维护一个连接表，最大长度固定。进程调用select尝试获取数据时，将连接表复制到内核里，由内核进程顺序遍历检查每个连接是否有数据事件更新，有的话做标记，然后再把更新后的表复制回用户态，用户态再遍历连接表，找到那些有数据事件更新的连接。</p>
<p>所以总共遍历两次，复制两次</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>本质上和select一样，只是固定长度表变成了变长的链表</p>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>用户态调用epoll_create，在内核态创建epoll对象。内核用一个红黑树维护所有连接，一个链表维护当前有事件的连接。有连接发生事件时，内核自动将其加入到链表中。当用户调用 epoll_wait() 函数时，内核只返回当前有事件的、链表中的连接对象。</p>
<p>插入新的连接维护对象，查找、更新，因为是红黑树所以都是 log(n)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>I&#x2F;O多路复用就是用一个进程维护多个I&#x2F;O流的连接，因为每个连接都用一个进程或线程去维护开销是很大的。</p>
<p>I&#x2F;O多路复用有三种模式，select、poll和epoll。select是采取轮询的模式，将所有连接维护在一个线性表里，每次select都将表复制到内核，由内核检查并更新是否有数据事件发生，再将结果复制回用户态，遍历获取事件更新状态。</p>
<p>poll和select类似，只是将线性表改成了链表，增加了最大并发连接数。</p>
<p>epoll则是在内核中用一个红黑树维护所有连接，有连接发生事件时，内核自动将其加入到一个链表中。当用户调用函数想知道哪些连接有数据事件发生时，内核只需要返回链表中的连接对象。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识复习笔记2-多线程编程</title>
    <url>/posts/4c5a7656/</url>
    <content><![CDATA[<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>经典问题。这个问题在本科学习操作系统时理解比较深刻，通常习惯从以下几个方面进行比较：</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>进程：进程是程序代码在计算机系统中运行时的一个状态体，代码是静态的，进程是动态的。进程是操作系统分配资源的基本单位，拥有独立的地址空间、代码段、数据段。</li>
<li>线程：线程是进程中可以独立执行的单元，是CPU调度的基本单位。一个进程可以有多个线程，同一个进程内的线程共享进程的资源，每个线程也拥有自己的线程栈、程序计数器等资源。</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>进程是资源分配单位，线程是最小执行单位。</li>
<li>进程切换开销大，每个进程都有自己的虚拟地址空间，也都有自己的页表。切换页表涉及到内存访问，页表切换后还会导致页表缓存（TLB）失效，都会导致额外时间开销。同一进程内线程切换不涉及虚拟地址空间切换，只需在线程栈保存上下文。</li>
<li>多进程适合多核多机并行执行，多线程适合多核。</li>
</ul>
<h4 id="C-的多线程编程"><a href="#C-的多线程编程" class="headerlink" title="C++的多线程编程"></a>C++的多线程编程</h4><p>C++11之前没有标准线程库，需要使用 pthread 库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pthread_create (pthread_t *thread,pthread_attr_t *attr,</span><br><span class="line">void *(*start_routine)(void *),void *arg);</span><br></pre></td></tr></table></figure>
<p>将要运行的函数的指针绑定到 pthread_t 对象上，并执行线程任务。</p>
<p>C++11增加了标准线程库 std::thread。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::thread t(foo, args...);</span><br></pre></td></tr></table></figure>
<p>指定要运行的函数foo和参数args，创建线程t并运行。</p>
<blockquote>
<p>C++11有两种方式来等待线程结束：</p>
<ul>
<li>detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。<ul>
<li>调用detach表示thread对象和其表示的线程完全分离；</li>
<li>分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看做是一个daemon线程；</li>
<li>分离之后thread对象不再表示任何线程；</li>
<li>分离之后joinable() &#x3D;&#x3D; false，即使还在执行；</li>
</ul>
</li>
<li>join方式，等待启动的线程完成，才会继续往下执行。假如前面的代码使用这种方式，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。<ul>
<li>只有处于活动状态线程才能调用join，可以通过joinable()函数检查;</li>
<li>joinable() &#x3D;&#x3D; true表示当前线程是活动线程，才可以调用join函数；</li>
<li>默认构造函数创建的对象是joinable() &#x3D;&#x3D; false;</li>
<li>join只能被调用一次，之后joinable就会变为false，表示线程执行完毕；</li>
<li>调用 ternimate()的线程必须是 joinable() &#x3D;&#x3D; false;</li>
<li>如果线程不调用join()函数，即使执行完毕也是一个活动线程，即joinable() &#x3D;&#x3D; true，依然可以调用join()函数；</li>
</ul>
</li>
</ul>
</blockquote>
<p>C++的线程thread创建之后就会运行，结束，销毁，如果要实现可复用的线程池，需要换一种思路：</p>
<ul>
<li>创建N个线程，让这些线程执行一个while函数，持续尝试向一个任务队列获取执行任务（执行任务：（函数地址，参数））。</li>
<li>线程获取到任务则执行，任务队列为空则阻塞休眠。</li>
<li>任务队列得到新任务时，唤醒一个休眠中的线程。</li>
<li>任务队列是一个生产者&#x2F;消费者模型，需要互斥。</li>
</ul>
<h4 id="Java的多线程编程"><a href="#Java的多线程编程" class="headerlink" title="Java的多线程编程"></a>Java的多线程编程</h4><p>Java多线程主要通过三种方式实现</p>
<ul>
<li>继承Thread类，重写<code>public void run()</code>方法，调用start()方法创建并执行线程任务</li>
<li>继承Runnable接口，重写<code>public void run()</code>方法，调用start()方法创建并执行线程任务</li>
<li>继承Callable接口，重写<code>public E call()</code>方法，调用start()方法创建并执行线程任务。call()可以有返回值</li>
</ul>
<h5 id="三种方式的共同点"><a href="#三种方式的共同点" class="headerlink" title="三种方式的共同点"></a>三种方式的共同点</h5><ul>
<li>Runnable和Callable本质上都是对Thread类的封装，其实创建执行线程还是由Thread完成的。所以说Java多线程也可以说就是new一个Thread对象，然后调用start()进行线程初始化、运行。</li>
<li>无论是继承Thread类还是继承两个接口，直接调用run()方法也是可以执行函数内容的，但并不会创建新线程，而是在main线程里执行。所以说真正关键动作在start()中</li>
</ul>
<h4 id="Java的同步和互斥"><a href="#Java的同步和互斥" class="headerlink" title="Java的同步和互斥"></a>Java的同步和互斥</h4><p>主要了解了synchronized关键词和ReentrantLock</p>
<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>关键词，可以修饰方法、对象、代码块。被修饰的内容在有一个线程访问时，其他试图访问的线程都会被阻塞。如果修饰的是静态方法，则该类所有对象的该方法都会被上锁（也很容易理解，静态方法是类级共享的）。</p>
<p>synchronized在早期给人的印象就是重量级锁，开销很大。因为它用到了操作系统底层的互斥锁，涉及到用户&#x2F;内核态切换。但是Java新版本也有做一些改进：</p>
<ul>
<li><strong>锁粗化</strong>：把多个连续的加锁解锁块合并为一个临界代码块。比如连续的字符串append</li>
<li><strong>锁消除</strong>：如果某个数据对象被认为是不会共享的，就不会对它上锁，比如一个函数内的局部变量，每个线程都是不同的，不会互相访问，就不会上锁</li>
<li><strong>轻量级锁</strong>：用<font color="red">CAS原子指令</font>代替重量级锁。<font color="red">CAS</font>就是compare and swap，线程将一个读取一个数据的值A，进行操作得到C，写回之前将A和原来的数据值比较，如果相同就写回C，不同就自旋反复尝试。</li>
<li><strong>偏向锁</strong>：通俗来说，偏向锁也是类似于82原则，一个被共享的的数据有80%的时间都在被同一个线程t1访问，只有20%的时间被其他线程访问。所以偏向锁就会给t1一个偏向锁认证，免去它访问时的CAS操作，只有当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。</li>
</ul>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>ReentrantLock就是可重入锁，一个线程获取到锁后，如果重复获取锁，不会被锁阻塞。重复获取n次锁，就要重复释放n次锁。</p>
<p>一般的使用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识复习笔记1-Java集合</title>
    <url>/posts/67cafe3d/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>复习笔记系列记录一些C++&#x2F;Java，本科专业课的一些知识，强化记忆</p>
<p>本科学习数据结构、算法、高级语言程序设计都是C++，Java是选修课。虽然大二的时候选过，但是就像自学的Python一样，会写代码但对基础原理理解不深，所以打算写笔记记录一些自己的学习理解，也方便以后查阅。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Java的集合也叫容器，类似于C++的stack容器适配器。C++中的stack、queue和priority_queue实际上底层都是deque容器，deque实现了它们所需的方法。Java中类似，所有容器都是从Collection和Map接口派生出来的，从Collection和Map接口又派生出许多子接口，由“集合（容器）”实现这些接口的方法。</p>
<ul>
<li><strong>Collection：</strong> 存放单一元素<ul>
<li><strong>List</strong>：ArrayList，LinkedList</li>
<li><strong>Set</strong>：HashSet，TreeSet，LinkedHashSet</li>
<li><strong>Queue</strong>：PiorityQueue<ul>
<li><strong>Deque</strong>：LinkedList，ArrayDeque</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map：</strong> 存放键值对<ul>
<li>HashMap，TreeMap，LinkedHashMap</li>
</ul>
</li>
</ul>
<p>以上黑体是接口，常规体是集合&#x2F;容器。</p>
<h4 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h4><p>ArrayList类似于C++的vector，底层用数组实现，可以随机访问、自动扩容。扩容机制也和vector类似，大约为1.5倍。</p>
<p>LinkedList是双向链表，头尾插入删除O(1)，随机位置插入删除平均仍然是O(n)，所以实际上与ArrayList相比优势不大，但适合作为双向队列的接口实现。</p>
<h4 id="HashSet，HashMap"><a href="#HashSet，HashMap" class="headerlink" title="HashSet，HashMap"></a>HashSet，HashMap</h4><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><p>HashMap和HashSet底层实现相同，都是数组+链表。当冲突形成的拉链表长度大于8，而且数组长度大于64时，会将链表转化为红黑树，降低查找开销。数组长度不大于64则优先数组扩容。</p>
<h5 id="下标计算"><a href="#下标计算" class="headerlink" title="下标计算"></a>下标计算</h5><p>HashSet类似于C++的unordered_set，元素存放无序、不可重复。计算元素存放位置时，先对元素进行一次hashCode()得到哈希值h，再将h和h的高16位或运算，得到最终的hash。然后<code>(n-1) &amp; hash</code>计算出下标。当n是2的幂次时，<code>(n-1)&amp;hash == hash % n</code>，所以HashMap表的长度总是2的幂次。</p>
<h5 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h5><p>插入的时候，先对元素进行hashcode计算，如果冲突，则调用equals对比元素的值，相同则覆盖值，不同则按照哈希冲突拉链处理。</p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>可以用foreach语法糖遍历，但遍历中不能对元素进行remove。如果需要遍历中对元素remove，需要用Iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; it = mp.entrySet().iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Object, Object&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foreach语法糖本质也是用迭代器遍历，但是remove会使用集合的remove方法，而不是迭代器的remove方法，导致出错。</p>
<p>不建议使用map.keySet()获取键表，然后用get(key)的方法遍历，相当于遍历了两次，效率很低。</p>
<h4 id="TreeSet和TreeMap"><a href="#TreeSet和TreeMap" class="headerlink" title="TreeSet和TreeMap"></a>TreeSet和TreeMap</h4><p>两者关系和HashSet、HashMap差不多，TreeMap是有序的，会默认按照键值升序排序。</p>
<h5 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h5><p>红黑树，查找和增删的复杂度相同，效率低于HashMap。</p>
<h5 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h5><ul>
<li>方法一：自定义类实现Comparable接口，在类中重写compareTo函数：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> v, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        ch = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hashCode和equals重写是为了让自定义类型在Set中去重</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(value).hashCode() + <span class="keyword">new</span> <span class="title class_">Character</span>(ch).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> (Node) o;</span><br><span class="line">        <span class="keyword">return</span> value == n2.value &amp;&amp; ch == n2.ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value &lt; o.value ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>方法二：在创建TreeMap时定义比较函数compare：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; mp = new TreeMap&lt;&gt;(new Comparator&lt;Character&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(Character o1, Character o2) &#123;</span><br><span class="line">      return o1 &lt; o2 ? 1 : -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>PiorityQueue默认是小顶堆，自定义比较的方法和TreeMap一样。</p>
<ul>
<li>poll和take都是取出一个元素，poll不会抛出异常</li>
<li>peek和element都是获取顶端元素，peek不会抛出异常</li>
<li>offer和add都是添加一个元素，offer不会抛出异常</li>
<li>Deque的offerFirst、pollLast等同理</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识复习笔记5-内存管理</title>
    <url>/posts/a2044ae4/</url>
    <content><![CDATA[<h3 id="C-的程序内存布局"><a href="#C-的程序内存布局" class="headerlink" title="C++的程序内存布局"></a>C++的程序内存布局</h3><p>从上往下是：</p>
<ul>
<li>内核空间：操作系统内核</li>
<li>环境变量，命令行参数</li>
<li>栈（高地址向低地址增长）：存放局部变量，函数参数，返回地址等，由编译器管理</li>
<li>（空闲区域）</li>
<li>堆（低地址向高地址增长）：由程序员new&#x2F;delete管理，容量远大于栈</li>
<li>BSS段：未初始化的数据</li>
<li>data段：已初始化的数据，全局变量，静态变量</li>
<li>text段：代码区</li>
</ul>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>C++没有垃圾回收机制，只能由程序员手动管理内存，一旦操作不当就可能导致：</p>
<ul>
<li>内存泄漏：某段代码每次执行都会申请一小段内存，结束后却不释放，久而久之就会吞噬系统的空闲内存，最终导致程序甚至系统崩溃。<ul>
<li>如果一段程序随着时间运行，内存占用越来越大且没有饱和的趋势，可能就出现了内存泄漏。</li>
<li>内存泄漏的静态检测方法，首先就是对代码进行检查，看是否有new&#x2F;delete不匹配的地方。</li>
<li>也可以用工具进行检查，比如valgrind可以检查程序是否有非法使用内存的问题。</li>
</ul>
</li>
</ul>
<p>另外一个方法是使用智能指针，智能指针会管理对象的生命周期，在其生命周期结束时自动释放内存。</p>
<ul>
<li>shared_ptr：可以允许多个指针指向一个对象，通过引用计数管理对象生命周期。</li>
<li>unique_ptr：对象只能由一个指针独享，可以移动对象所有权，但不能复制。</li>
<li>weak_ptr：主要避免shared_ptr造成的循环引用，A引用B，B引用A，这样谁都无法被释放。weak_ptr可以提供某个对象的访问，但是不会参与引用计数。需要用时，使用lock方法来获得一个shared_ptr对象。</li>
</ul>
<h4 id="C-类的内存布局"><a href="#C-类的内存布局" class="headerlink" title="C++类的内存布局"></a>C++类的内存布局</h4><p>对于一般的类，所有非静态成员变量按照声明顺序，内存对齐原则放在一起。静态成员变量放在全局数据区，所有类成员函数是放在代码区，位置没有明显关联。</p>
<p>有虚函数的类，类的地址起始位置有一个虚函数指针，指向虚函数表，虚函数表中存放了所有虚函数的入口地址。紧接着放非静态成员变量。子类在构造时也会有一个虚函数表，如果子类重写了虚函数，则会用新的函数地址覆盖掉表中原来的虚函数地址。</p>
<p>继承的话，继承类先按照其继承的基类的顺序，存放了各个基类的成员变量和各自的虚函数表指针，再存放自己的数据成员。</p>
<p>基类析构函数声明为虚函数：这样才能在基类指针调用析构时，执行子类的析构函数，不然可能出现局部释放的情况，只释放了基类的相关内容，子类的却没有释放，造成内存泄漏。</p>
<h3 id="Java的内存管理"><a href="#Java的内存管理" class="headerlink" title="Java的内存管理"></a>Java的内存管理</h3><p>Java有垃圾回收机制，不需要程序员手动管理内存分配和释放，</p>
<h4 id="Java的垃圾回收策略"><a href="#Java的垃圾回收策略" class="headerlink" title="Java的垃圾回收策略"></a>Java的垃圾回收策略</h4><p>根据JVM实现的不同，策略也有所不同。Java的堆内存区域一般可以分为新生代、老年代和永久代三块，新生代一般是生命周期比较短的对象，老年代是占用内存比较大，生命周期较长的对象，永久代则是始终不会被清理的对象。</p>
<p>分配内存时，优先在新生代区域分配，如果内存不够，则尝试将新生代的部分对象转移到老年代。如果分配的对象很大，则会直接进入到老年代，减少垃圾回收的频率和成本。每个对象都有一个年龄计数器，每次垃圾回收没有被清理的对象年龄就会增加，增加到一定数值就会转移到老年代区域。</p>
<h4 id="判断对象生命周期"><a href="#判断对象生命周期" class="headerlink" title="判断对象生命周期"></a>判断对象生命周期</h4><ul>
<li>引用计数：类似于C++的shared_ptr，但是也有循环引用的问题，使用的比较少。</li>
<li>可达性分析算法：从以下对象中选择根对象，搜索根对象引用的对象，如果一个对象没有一条到达根对象的引用链，就说明它该被回收了。（我理解的就是从“钉子户”开始链式搜索，因为“钉子户”引用的对象一定是被需要的）<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
<li>JNI（Java Native Interface）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li>标记-清除算法：标记所有不用的对象，然后再依次清除。<ul>
<li>简单，但是容易产生内存碎片，标记和清除的效率低</li>
</ul>
</li>
<li>复制算法：将内存划为两半，只用其中一半存放对象。内存满后，将还存活的对象复制到另一边，直接清除掉当前这边的内存。<ul>
<li>清除的效率更高，但可用内存变小了，且不适用于老年代对象，因为复制开销大</li>
</ul>
</li>
<li>标记-整理算法：标记所有存活的对象，将他们向内存的一端整理移动，然后清除掉另一端的内存。<ul>
<li>整理的效率比较低</li>
</ul>
</li>
</ul>
<h5 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h5><p>新生代使用复制算法，因为新生代的对象存活概率低，大概率不需要复制很多内容。<br>老年代使用标记整理算法，老年代的对象通常比较大。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识复习笔记7-泛型和模板类</title>
    <url>/posts/10facbba/</url>
    <content><![CDATA[<h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3><p>模板类是C++泛型编程的实现之一，STL的容器都是模板类实现的。模板类可以不具体指定数据的类型，实现一份代码多处复用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> E,...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(T x, E, y) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">fun</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> t; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T a;</span><br><span class="line">    E b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板函数类似。</p>
<h3 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h3><p>Java的泛型写法和C++类似，前面不需要加template标识。</p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul>
<li>C++的模板类实际上是编译的时候，对于每一种用到的类都复制生成一份代码，vector<int>和vector<double>会生成两个不同的类。</double></int></li>
<li>Java的泛型在编译的过程中会进行类型擦除，将泛型改成Object类，只生成一份代码。</li>
<li>由于只生成了一份代码，Java的泛型程序在运行过程中需要进行类型转换和类型检查，将Object的类转为实例类型的类。</li>
<li>由于实际上Java的泛型是通过类型转换和类型检查实现的，所以Java的泛型类、泛型方法等，其中的泛型数据可以指定类型范围（extends T：必须是T的子类，super T，必须是T的父类）</li>
<li>类型参数T和通配符?。类型参数用于声明泛型类，?用在泛型类的使用中。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识复习笔记4-计算机网络</title>
    <url>/posts/3d21fd56/</url>
    <content><![CDATA[<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP和UDP都是传输层协议，负责端到端的数据传输，主要区别是：</p>
<ul>
<li>TCP是有连接的，UDP是无连接的。TCP传输数据前需要三次握手建立连接，UDP只需要知道对方IP和端口即可发送数据。</li>
<li>TCP是可靠传输协议，UDP是不可靠的。UDP只管发送数据，不会关心数据包是否到达。TCP则需要保证每一个数据分片都能可靠地交付给对方，所以引入了序列号、确认号、超时重传等机制。</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li>第一次握手是客户端向服务提供端发起SYNC同步请求，并且附带自己的序列号。</li>
<li>第二次握手是服务提供方接收到连接请求后，返回一个确认数据包，这个数据包也包含了他自己的序列号，以及SYNC同步标志。</li>
<li>客户端收到第二次握手的确认包后，再返回一个ACK确认数据包，连接才建立，之后发送数据。</li>
</ul>
<h5 id="为什么要三次而不是两次"><a href="#为什么要三次而不是两次" class="headerlink" title="为什么要三次而不是两次"></a>为什么要三次而不是两次</h5><ul>
<li>如果只有两次握手，实际上只有客户端确认了服务端能够连接，服务端是不知道客户端的连接状态的。假如第二次握手丢失，客户端放弃了连接，而服务端直接就开始发送数据，会造成资源浪费。</li>
<li>假如第一次握手的数据包在网络中滞留，过一段时间，早就失效的数据包传到服务端，服务端以为是新的连接请求，于是产生第二次握手，然后就以为连接建立了，但实际上这时候客户端已经没有传输需求了，也不会回应服务端，也会造成资源浪费。</li>
</ul>
<h5 id="为什么不是四次"><a href="#为什么不是四次" class="headerlink" title="为什么不是四次"></a>为什么不是四次</h5><p>第二次握手实际上把确认收到，和发起连接请求合并到一起了。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li>第一次挥手：客户端发送FIN数据包，表明打算断开连接，它不再发送数据，但是可以接收数据，进入FIN-WAIT1状态。</li>
<li>第二次挥手：服务端收到FIN数据，回复一个ACK，表明它知道对方打算断开连接。客户端收到后，进入FIN-WAIT2状态。服务端进入CLOSE-WAIT状态。</li>
<li>中间 ：服务端继续发送未传输完毕的数据</li>
<li>第三次挥手：服务端发送FIN数据包，请求关闭连接，进入LAST-ACK状态。</li>
<li>第四次挥手：客户端回复ACK，进入TIME-WAIT状态，等到两个报文段最长寿命后，CLOSE连接。如果这段时间内收到了服务端的第三次挥手重传，说明第四次挥手没成功发送过去，重传。</li>
</ul>
<h5 id="为什么要等两个报文段最长寿命"><a href="#为什么要等两个报文段最长寿命" class="headerlink" title="为什么要等两个报文段最长寿命"></a>为什么要等两个报文段最长寿命</h5><p>因为第四次挥手后，客户端无法得知对方是否收到数据包，并且关闭连接。两个报文段最长寿命就是一发一收的时间，如果这个时间段内没有收到超时重传的消息，就认为服务端收到了最后的ACK。</p>
<p>如果不等待的话，服务端可能没收到第四次挥手数据，连接无法正常关闭造成资源浪费。</p>
<h4 id="TCP的拥塞控制、流量控制、滑动窗口等等"><a href="#TCP的拥塞控制、流量控制、滑动窗口等等" class="headerlink" title="TCP的拥塞控制、流量控制、滑动窗口等等"></a>TCP的拥塞控制、流量控制、滑动窗口等等</h4><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p>拥塞控制是针对网络的，避免网络中存在过多的报文造成网络信道拥堵。主要用慢开始、拥塞避免算法，快速重传、快速回复。</p>
<p><strong>慢开始、拥塞避免</strong><br>发送方维护一个拥塞窗口大小，最开始拥塞窗口为1个单位，每次成功收到确认后就将窗口大小加倍。当窗口大小大于阈值时，就执行拥塞避免算法，每次窗口大小加一个单位。</p>
<p>如果出现数据丢失，将窗口设为1，执行慢开始算法，并且阈值设为数据丢失时的窗口大小的一半。</p>
<p><strong>快重传、快恢复</strong><br>快重传是，如果发送方收到连续三个重复确认就立刻重传对方尚未收到的报文段，而不是等重传计时器时间到期。</p>
<p>同时，因为能收到三个重复ACK，所以认为网络虽然拥堵，但还是有一定的运输能力，所以窗口不会设为1，而是设为阈值减半后的大小，并且继续执行拥塞避免算法。</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>流量控制是针对发送方和接收方数据处理能力的。双方各自维护一个窗口，并且在发送数据时会告知对方自己空闲窗口大小，如果窗口没有空闲，就会减缓数据发送速度。</p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>滑动窗口的设置是为了避免出现每一个数据包发送后都要等待确认才能发送下一个数据包这样的情况，效率很低。滑动窗口外的左侧，可以看作是已经发送、确认的数据包；滑动窗口内的话，只有最左侧边缘的连续的数据包被确认了，窗口才会向右移动。</p>
<h3 id="输入网址后发生的事情"><a href="#输入网址后发生的事情" class="headerlink" title="输入网址后发生的事情"></a>输入网址后发生的事情</h3><ol>
<li>URL解析：url是统一资源定位符，为了访问服务器的资源，需要将url解析为IP地址，就会用到DNS协议。如果浏览器有域名缓存，或者系统本地有相应的hosts项，那就不用再向DNS服务器发送请求，直接就可以解析。如果没有的话，主机就会依次向本地、上级的DNS服务器递归地发送请求。</li>
<li>解析得到IP地址后，为了传输HTTP请求，还要和服务器建立TCP连接，也就是三次握手。传输层往下，网络层根据IP对数据包进行转发，再往下还有ARP协议通过IP地址获得下一次转发的MAC地址。</li>
<li>TCP连接建立后，服务器收到HTTP请求，将网页资源封装，再传给主机。主机收到网页资源数据后，由浏览器进行解析和渲染，同时页面内如果还有其他资源，则还会构造相应的HTTP请求去获取这些资源文件。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：切分数组，两侧和最大公约数</title>
    <url>/posts/e60cd48e/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>将一个数组任意排序，并切分成两段，两段和的最大公约数。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul>
<li>最开始想排序贪心，但不太对</li>
<li>实际上因为数据范围1-1000，应该遍历每一种求和情况，DFS<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> max_gcd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = (temp % y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> index, <span class="type">int</span> cur_sum, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= arr.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(cur_sum))</span><br><span class="line">    &#123;</span><br><span class="line">        mp.<span class="built_in">insert</span>(cur_sum);</span><br><span class="line">        max_gcd = <span class="built_in">max</span>(max_gcd, <span class="built_in">gcd</span>(cur_sum, sum - cur_sum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(arr, index + <span class="number">1</span>, cur_sum + arr[index], sum);</span><br><span class="line">    <span class="built_in">dfs</span>(arr, index + <span class="number">1</span>, cur_sum, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(arr, <span class="number">0</span>, <span class="number">0</span>, sum);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;maxgcd: &quot;</span> &lt;&lt; max_gcd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>基础知识学习笔记6-Spring</title>
    <url>/posts/ccf09792/</url>
    <content><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>Spring是Java的一个轻量级开发框架，包含了很多模块，可以帮助开发人员快速构建应用，提高开发效率。其中最核心的模块就是IoC（控制反转）和AOP（面向切片编程）</p>
<h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>控制反转的核心就是让Spring框架来管理程序中需要的对象实例，而不是由程序自己手动创建。</p>
<ul>
<li>不需要考虑实例化某个类需要构造怎样的参数，只要配置好，在需要用的时候，向IOC容器拿就可以了。</li>
<li>如果某个类A用到了一个接口B，因为接口不能被实例化，所以就必须指定B的实现类。但是使用IOC的话，定义接口不需要指定实现类，在需要的时候在IOC容器中获取就可以了<ul>
<li>比如在Service类里定义了操作数据库的DAO接口，用注解@Autowired就可以自动注入DAO对象实例</li>
</ul>
</li>
</ul>
<h4 id="面向切片编程"><a href="#面向切片编程" class="headerlink" title="面向切片编程"></a>面向切片编程</h4><p>面向切片编程和面向对象编程并不冲突，目的是将一些通用的操作和功能与业务功能代码分离开，提高代码的可读性和可维护性。比如像日志记录，如果每个类都重复实现日志的功能，就会有很多重复的冗余代码，维护起来很麻烦。所以面向切片就是把这些代码分离出来。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>除法取模</title>
    <url>/posts/87d1f055/</url>
    <content><![CDATA[<h3 id="前要"><a href="#前要" class="headerlink" title="前要"></a>前要</h3><p>加减乘的取模运算满足分配律，但是除法不满足</p>
<h4 id="方法1：费马小定理"><a href="#方法1：费马小定理" class="headerlink" title="方法1：费马小定理"></a>方法1：费马小定理</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a/b % p == a*(b^(p-2))%p</span></span><br><span class="line"><span class="comment">// p为素数</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (a^b)%p</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res*a % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a*a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">a_div_b_mod_p</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a%p)*(<span class="built_in">pow</span>(b, p<span class="number">-2</span>, p)%p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>计算a，b最大公约数的同时算出逆元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ex_gcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x即为逆元</span></span><br><span class="line">    <span class="comment">// ax + by == gcd(a, b)</span></span><br><span class="line">    <span class="comment">// ax === 1(mod m)</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ex_gcd</span>(b, a%b, x, y);</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp - a/b * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>如何提问、如何解决遇到的问题</title>
    <url>/posts/9429079c/</url>
    <content><![CDATA[<h3 id="提问之前"><a href="#提问之前" class="headerlink" title="提问之前"></a>提问之前</h3><ul>
<li>作为计算机专业的学生，你遇到的大部分问题都是别人已经遇到过、有成熟的解决方案的。那么关键在于，“怎样才能正确地找到这些问题的答案”。需要准备的：</li>
</ul>
<h4 id="正确的搜索引擎"><a href="#正确的搜索引擎" class="headerlink" title="正确的搜索引擎"></a>正确的搜索引擎</h4><ul>
<li>你应该使用Google，而不是baidu或其他国内搜索引擎</li>
<li>（如何在国内使用Google不做说明）</li>
<li>如果是代码问题，你可以在github尝试搜索类似的项目，并参考他们的项目架构和代码写法（<font color="red">但不要抄袭</font>）</li>
</ul>
<h4 id="正确的搜索方式"><a href="#正确的搜索方式" class="headerlink" title="正确的搜索方式"></a>正确的搜索方式</h4><ul>
<li>确保你已经尝试过自行搜索、解决该问题，并没有找到办法。</li>
<li>你不应该搜索“电脑蓝屏了怎么办”，而是问出具体的“电脑出现错误代码XXXXXXX”，并且尽量使用关键词组合，而不是自然语言问句。</li>
<li>如果允许，你应该使用英文搜索你的问题。</li>
<li>从报错代码中先推测可能出现的问题，因为很多时候报错代码报出的是一个宽泛的错误，造成错误的原因可能大相径庭。例如C语言中常常出现的段错误，直接搜索“段错误”完全无法确定你遇到的是哪个问题。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>远程软件控制Manjaro</title>
    <url>/posts/1075cfa9/</url>
    <content><![CDATA[<h3 id="为什么要用Manjaro"><a href="#为什么要用Manjaro" class="headerlink" title="为什么要用Manjaro"></a>为什么要用Manjaro</h3><p>实验室电脑配置很旧，且常年不关机导致硬件老化严重，很难带动Windwos系统，于是把系统盘格式化了<br>受人影响想试试arch linux，又有点怕麻烦所以用了Manjaro</p>
<h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><p>Manjaro可以用pacma build直接构建软件</p>
<p>记得在teamviewer官网上把以前的电脑给删除了，不然限制用户数</p>
<p>anydesk也还可以用</p>
<h3 id="解决远程软件无法显示（黑屏）"><a href="#解决远程软件无法显示（黑屏）" class="headerlink" title="解决远程软件无法显示（黑屏）"></a>解决远程软件无法显示（黑屏）</h3><p>在&#x2F;etc&#x2F;gdm3&#x2F;custom.conf，允许自动登录，填上用户名</p>
<p>最后一行设置<code>WaylandEnable=false</code></p>
<h3 id="解决无显示器导致卡顿"><a href="#解决无显示器导致卡顿" class="headerlink" title="解决无显示器导致卡顿"></a>解决无显示器导致卡顿</h3><p>安装xf86，sudo pacman -S xf86-video-dummy</p>
<p>修改配置 sudo gedit &#x2F;etc&#x2F;X11&#x2F;xorg.conf</p>
<p>抄来的配置，随便了能用就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier  &quot;Configured Video Device&quot;</span><br><span class="line">    Driver      &quot;dummy&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">    Identifier  &quot;Configured Monitor&quot;</span><br><span class="line">    HorizSync 31.5-48.5</span><br><span class="line">    VertRefresh 50-70</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">    Identifier  &quot;Default Screen&quot;</span><br><span class="line">    Monitor     &quot;Configured Monitor&quot;</span><br><span class="line">    Device      &quot;Configured Video Device&quot;</span><br><span class="line">    DefaultDepth 24</span><br><span class="line">    SubSection &quot;Display&quot;</span><br><span class="line">        Depth 24</span><br><span class="line">        Modes &quot;1920x1080&quot;</span><br><span class="line">    EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>露营物品列表</title>
    <url>/posts/59b9e0e2/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>确定目的地。如果选择有人经营的露营营地，可以减少一些装备的准备。如果是无人看守的地方，最好提前看好附近有无公共厕所。</li>
<li>预订酒店。有些地方会提供民宿+野外烧烤的服务，也可以在露营地附近订住宿。露宿野外有风险。</li>
<li>提前一天入住酒店，第二天早上开始活动，可以视情况晚上收摊或酒店再住一晚。</li>
</ol>
<h3 id="物品列表"><a href="#物品列表" class="headerlink" title="物品列表"></a>物品列表</h3><ul>
<li>可折叠桌椅。椅子数量 &#x3D; 人数</li>
<li>地垫。2到3张</li>
<li>露营用天幕 &#x2F; 帐篷。天幕优先级 &gt; 帐篷</li>
<li>烧水壶 + 水杯</li>
<li>一次性烧烤架。2个（大概能烤3小时）</li>
<li>打火石。（比打火机用起来炫酷一些）</li>
<li>应急灯。手电筒</li>
<li>小刀</li>
<li>一次性餐具。份数 &#x3D; 人数 * 2。也可以自带餐盒。</li>
<li>酒精湿巾</li>
<li>抽纸</li>
<li>矿泉水。6L一桶</li>
</ul>
<h3 id="食品列表"><a href="#食品列表" class="headerlink" title="食品列表"></a>食品列表</h3><p><strong><font color="red">野外烧烤 &#x2F; 方便食品 &#x2F; 零食 &#x3D; 4：4：2</font></strong></p>
<hr>
<ul>
<li>烤肉串。商超里有冷冻腌制串，一包</li>
<li>烤肉肠。同上，一包</li>
<li>馒头。同上，一包吃不完</li>
<li>玉米。能烤熟但比较费时间</li>
<li>番茄。切开烤</li>
<li>不方便处理的食材：土豆、藕等蔬菜。烧烤买半成品可以节省野外处理时间</li>
</ul>
<hr>
<ul>
<li>杯面。合味道</li>
<li>自热米饭、自热火锅</li>
<li>甜皮鸭，等熟食</li>
<li>因为有烧烤和零食，杯面、米饭和火锅的数量总和 &lt; 人数</li>
</ul>
<hr>
<ul>
<li>饮料</li>
<li>膨化食品</li>
<li>水果</li>
</ul>
<h3 id="暂时先写这些"><a href="#暂时先写这些" class="headerlink" title="暂时先写这些"></a>暂时先写这些</h3><p>还有娱乐项目自带</p>
]]></content>
      <categories>
        <category>玩乐</category>
      </categories>
      <tags>
        <tag>露营</tag>
      </tags>
  </entry>
  <entry>
    <title>2nd, and 3rd</title>
    <url>/posts/669ed615/</url>
    <content><![CDATA[<h1 id="でぃすかばりー☆じゃーにー"><a href="#でぃすかばりー☆じゃーにー" class="headerlink" title="でぃすかばりー☆じゃーにー"></a>でぃすかばりー☆じゃーにー</h1><p>2025&#x2F;02&#x2F;16  東京新宿Zepp</p>
<h3 id="1-急行特种兵"><a href="#1-急行特种兵" class="headerlink" title="1. 急行特种兵"></a>1. 急行特种兵</h3><p>live昼场是下午两点半开场的，而我们的航班是当天上午8点—11点，几乎要全速冲刺才能勉强赶上开场排号。恰巧当天航班又延误了一会，大概到 9:20 才起飞，落地到入境排队时已经是13点过了。在机场、车站一路全速冲刺，勉强在开场前15分钟左右赶到了新宿Zepp。</p>
<p>至于为什么要买这个时间的机票，因为15号是上海Roselia公演……订票的当时，还打算15号看Roselia，16号看梦限大。但实际上是根本没抢到票，当天装了一天的电脑。结果来看，如果15号晚上去看了Roselia，第二天再这么跑，铁人都要倒下了。</p>
<h3 id="2-准备运动"><a href="#2-准备运动" class="headerlink" title="2. 准备运动"></a>2. 准备运动</h3><p>第一次去现地Live，很多问题都是同行帮我解决的，比如机票、住宿、交通等等，我自己准备的几乎只有护照和信用卡，以及提前在机场预订的便携式WiFi。回头想了想，需要准备的工作还是挺多的：</p>
<ol>
<li><strong>护照和签证</strong>：手续齐全了在飞猪上很好办，把资料打印一份寄到旅行社，再寄一份电子版到旅行社邮箱就可以了。比较麻烦的可能是在日本住处、联系人之类的。我填的是酒店的地址</li>
<li><strong>机票</strong>：携程就可以订，按价格从低到高排序（</li>
<li><strong>酒店</strong>：还没订过。携程什么的可以订，但似乎办各连锁酒店的会员，在官网订更便宜</li>
<li><strong>交通</strong>：有一张交通卡是最好的，如果是iPhone可以在钱包里添加虚拟交通卡。实体交通卡还不能用信用卡充值，还是iPhone方便</li>
<li><strong>饮料费</strong>：live house进场要600円入场费，有些地方可以用交通卡，有些地方只收现金。进场后可以换一杯饮料（但是完全没空喝）</li>
<li><strong>储物柜</strong>：只能投币的储物柜，还得准备现金换硬币</li>
</ol>
<p>这次去基本上是跟着跑，现金也是借的</p>
<h3 id="3-昼场"><a href="#3-昼场" class="headerlink" title="3. 昼场"></a>3. 昼场</h3><p>昼场是多少号已经记不清楚了，虽然是A区，但进场后放包和衣服花了不少时间。我穿了一件羽绒服、一件卫衣和一件短袖，只带了一个摇曳露营的手提包，想把这么多东西放到一个看起来只有50*50底面积的柜子里真有点拼尽全力。最终是把衣服和大部分谷子塞了进去，手提包里放了水、充电宝和移动WiFi（彻底断网还是有点心虚）</p>
<p>因为在储物区折腾太久，进到A区已经是人挤人人攮人人推人的状况了。我站在场地左后方，后面不远就是二楼神人区。站旁边的人是一个1米8大汉，前面人也很多，基本上看不到舞台上的情况，全场只听得到声音，眼镜还差点被薅掉。</p>
<h4 id="Live部分"><a href="#Live部分" class="headerlink" title="Live部分"></a>Live部分</h4><p><img src="/posts/669ed615/image.png" alt="alt text"></p>
<p>说实话，我已经记不太清歌曲顺序了，所以截了个图。</p>
<hr>
<p>第一首是コハク，あられ的个人曲，这也是我最喜欢的歌。不知道该如何表述，总之我觉得这是一首<em>节奏</em> 比较特别的歌，副歌部分还有可能是全梦团曲最高音。あられ唱高音非常有穿透力，能感觉到声音直击灵魂。我一直有点羡慕能唱高音的人，但あられ的高音比较特别，让人听起来像是在燃烧生命去唱歌一样。小羊唱歌拼命的感觉是快要气尽力竭，而あられ唱歌不会让人担心断气、反而是担心她体力不支倒下。唱歌的时候，除了编排好的动作以外，あられ还会无意识地做一些像点头打节拍这样的小动作，太可爱了。</p>
<p>第二首是ag翻唱过的V+曲，说实话我以前没有怎么听过，还好跟着大家打call糊弄过去了。中间あられ会像大姐头一样给大家做发声训练，要喊很多次もっともっともっともっと，也是一首体感火热的歌</p>
<p>第三首是hhw翻唱过的V+曲，外星人。这首歌听过很多，全员都会跳舞，大家在底下call的时候也会蹦（但我拿着包实在不好蹦）。还有奶油糖歌曲里经典的拍手，实话实说我拍手不太响</p>
<p>唱完外星人后的MC，我记得大家还演了一会儿外星人，最后实在是绷不住了才开始正常MC的。喊ユノち的人非常多，噶池太多了</p>
<p>第四首是エンプティパペット，律ちゃん的个人曲。歌词挺阴郁的，但是节奏又比较快，容易让人high起来，尤其是间奏部分，感觉头就快要甩起来了。这一场收音还可以，律ちゃん的念白部分基本上都听到了</p>
<p>第五首是慢节奏的壱雫空，就是go友说的没有疾走感的版本。前面的几首歌都比较快，人挤人加上场地封闭，几首歌call下来现场就热气腾腾了，全身是汗。这首歌差不多正好休息下。因为没听过MyGO现场版的，所以我也不知道疾走感到底是啥感觉。听あられ清唱的版本，能明显感受到她非常强劲的歌力</p>
<p>第六首是律ちゃん第二首个人曲TRASH LIFE（拖拉阿西来福），背后有nanimono成员出演的MV播放。日本人的英语发音啊…… 节奏很轻快的歌</p>
<p>中间MC忘记说啥了</p>
<p>第七首又是hhw，真正带来笑容的乐队。这首歌我也蛮喜欢的，像儿歌（梦限大某种意义上和hhw还挺像的，梦限大是live名全平假名，hhw是歌曲名都是平假名</p>
<p>第八首，喊得最爽的一曲，在我那边听到喊律酱的声音最大。喊完あられ还能听到现场本人的害羞声へへどうも～ 太幸福了</p>
<p>第九首，ののか个人曲动物派对，也是底下观众狂call的一曲，不过当时我还不太记得哪些地方该接。现在倒是熟悉了</p>
<p>第十首，ユノ个人曲ビッグマウス，出来的时候全场沸腾（yuno’s真的多）。到副歌的时候就真的已经是蹦迪环节了，不过我带着包放不开，没敢跳。也就是这个时候旁边的肥肥把我眼镜差点碰掉</p>
<p>第十一首，都子老师个人曲限界現実サバイブ天使，这首歌当时我也不熟悉在哪里接call，还是预习少咯额，“X”都没举（而且当时我只有一根棒子，有两个才好举X）。</p>
<p>最后第十二首，1单新歌コミュ着火Fire!，这好像也是当时最high的一首歌，全体都在Q&amp;A VS WHY</p>
<p>安可路环节之前是国王的谷子宣传视频，这部分就留到之后再写吧，先上传</p>
]]></content>
      <categories>
        <category>玩乐</category>
      </categories>
      <tags>
        <tag>梦限大</tag>
      </tags>
  </entry>
</search>
