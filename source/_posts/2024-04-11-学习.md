---
title: 2024-04-11-学习
header_image: /intro/post-bg.jpg
abstract: oc/swift/c++
categories: 学习
tags: []
abbrlink: f44a7f04
date: 2024-04-11 14:34:11
---

### objective-C
objective-C是C语言的超集，属于面向对象的编程语言，但是它有一个比较核心的概念叫Smalltalk，消息传递机制，导致oc和C++的编写方法略有差异。

- objective-C是C语言的严格超集，所有C语言的程序都可以直接被通过oc编译器，也可以直接使用C语言语法

#### Smalltalk
Smalltalk是oc的面向对象语法，用法差距和C++对象调用方法很大，与其说是对象调用方法，不如说是对象之间传递消息。
举例来说：
- C++：obj.method(arg1, arg2); 这是对象obj调用method方法
- oc：[obj method : arg1, arg2]; 这是发送一个method的消息给obj对象，即使obj没有method方法，程序也能通过编译，在运行期runtime抛出异常。

因为运行期才会处理消息，所以可以发送未知消息给对象，即可以很方便实现动态绑定（运行期才决定调用哪个方法）

#### 字符串
oc当然可以接受C风格字符串，但是通常使用NSString。
- 从常量创建NSString对象：NSString* str = @"a string"; 使用‘@’符号标注即可。

#### 类
oc的类声明和C++相似，但看起来差别又很大。
```objective-c
@interface A : NSObject {
    int a; //默认为protected
    @public
        char b;
    @private 
        NSString* c;
@property NSString* c; //属性
}
+(int) class_fun1: (int) arg1 andPar: (char) arg2;

-(void) instance_fun1;
-(char) instance_fun2: (char) arg1;
@end
```
大括号里面的是类成员变量，函数方法格式为：
- +/-(返回类型) 函数名称 : (参数类型) 参数名 andPar: ...
- +表示类级方法，即静态方法，-表示实例方法，即成员方法
- @interface和@end标识类的开始和结束
- 将变量声明为@property属性，可以自动生成getter和setter方法，减少重复代码

#### 类的实现
```objective-c
@implementation A : NSObject {
    int d; //默认为private
}
@synthesize c; //这里自动生成getter和setter
+(int) class_fun1: (int) arg1 andPar: (char) arg2 {
    //实现
}

-(void) instance_fun1 {

}
-(char) instance_fun2: (char) arg1 {

}
@end

```
实现模块也可以定义变量，默认为private。

#### 创建对象
一般的创建对象方法：
- A *a = [[A alloc] init]，init是默认构造函数
- 上述写法等同于 A *a = [A new]，相当于合并调用alloc和init

自定义构造方法：
- 格式必须为 -(A) initWith... : (type) arg1 : (type) arg2
- 调用方法 A *a = [[A alloc] initWithXXX : arg1_val arg2 : arg2_val]
- 多参数方法中，第一个参数的名称默认为方法名，从第二个参数开始为参数名，参数之间空格隔开

#### 协议
协议类似于Java的接口，就是一组没有实现的方法集合。

```objective-c
@protocol Sem
-(void) P;
-(void) V;
@end
```

声明实现协议：
```objective-c
@interface A : NSObject<Sem>
// 声明后，implemention就必须实现P和V方法
@end
```




### C++迭代器失效
vector，使用insert或erase之后，之后的元素的迭代器都会失效。容器扩容，所有迭代器都会失效。应当使用insert或erase返回的迭代器。

map，erase后被删除的迭代器失效，因此无法执行++操作，需要在删除前保存下一个迭代器位置。


