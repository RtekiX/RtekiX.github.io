---
title: 基础知识复习笔记2-多线程编程
header_image: /intro/post-bg.jpg
abstract: C++和Java的多线程
categories: 学习
tags:
  - 笔记
abbrlink: 4c5a7656
date: 2024-02-13 22:32:08
---

### 线程和进程
经典问题。这个问题在本科学习操作系统时理解比较深刻，通常习惯从以下几个方面进行比较：

#### 定义
- 进程：进程是程序代码在计算机系统中运行时的一个状态体，代码是静态的，进程是动态的。进程是操作系统分配资源的基本单位，拥有独立的地址空间、代码段、数据段。
- 线程：线程是进程中可以独立执行的单元，是CPU调度的基本单位。一个进程可以有多个线程，同一个进程内的线程共享进程的资源，每个线程也拥有自己的线程栈、程序计数器等资源。

#### 区别
- 进程是资源分配单位，线程是最小执行单位。
- 进程切换开销大，每个进程都有自己的虚拟地址空间，也都有自己的页表。切换页表涉及到内存访问，页表切换后还会导致页表缓存（TLB）失效，都会导致额外时间开销。同一进程内线程切换不涉及虚拟地址空间切换，只需在线程栈保存上下文。
- 多进程适合多核多机并行执行，多线程适合多核。

#### C++的多线程编程
C++11之前没有标准线程库，需要使用 pthread 库。
```
int pthread_create (pthread_t *thread,pthread_attr_t *attr,
void *(*start_routine)(void *),void *arg);
```
将要运行的函数的指针绑定到 pthread_t 对象上，并执行线程任务。

C++11增加了标准线程库 std::thread。
```
std::thread t(foo, args...);
```
指定要运行的函数foo和参数args，创建线程t并运行。

> C++11有两种方式来等待线程结束：
> 
> - detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。
>   - 调用detach表示thread对象和其表示的线程完全分离；
>   - 分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看做是一个daemon线程；
>   - 分离之后thread对象不再表示任何线程；
>   - 分离之后joinable() == false，即使还在执行；
> - join方式，等待启动的线程完成，才会继续往下执行。假如前面的代码使用这种方式，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。
>   - 只有处于活动状态线程才能调用join，可以通过joinable()函数检查;
>   - joinable() == true表示当前线程是活动线程，才可以调用join函数；
>   - 默认构造函数创建的对象是joinable() == false;
>   - join只能被调用一次，之后joinable就会变为false，表示线程执行完毕；
>   - 调用 ternimate()的线程必须是 joinable() == false;
>   - 如果线程不调用join()函数，即使执行完毕也是一个活动线程，即joinable() == true，依然可以调用join()函数；

C++的线程thread创建之后就会运行，结束，销毁，如果要实现可复用的线程池，需要换一种思路：
- 创建N个线程，让这些线程执行一个while函数，持续尝试向一个任务队列获取执行任务（执行任务：（函数地址，参数））。
- 线程获取到任务则执行，任务队列为空则阻塞休眠。
- 任务队列得到新任务时，唤醒一个休眠中的线程。
- 任务队列是一个生产者/消费者模型，需要互斥。

#### Java的多线程编程
Java多线程主要通过三种方式实现
- 继承Thread类，重写`public void run()`方法，调用start()方法创建并执行线程任务
- 继承Runnable接口，重写`public void run()`方法，调用start()方法创建并执行线程任务
- 继承Callable接口，重写`public E call()`方法，调用start()方法创建并执行线程任务。call()可以有返回值

##### 三种方式的共同点
- Runnable和Callable本质上都是对Thread类的封装，其实创建执行线程还是由Thread完成的。所以说Java多线程也可以说就是new一个Thread对象，然后调用start()进行线程初始化、运行。
- 无论是继承Thread类还是继承两个接口，直接调用run()方法也是可以执行函数内容的，但并不会创建新线程，而是在main线程里执行。所以说真正关键动作在start()中

#### Java的同步和互斥
主要了解了synchronized关键词和ReentrantLock

##### synchronized 
关键词，可以修饰方法、对象、代码块。被修饰的内容在有一个线程访问时，其他试图访问的线程都会被阻塞。如果修饰的是静态方法，则该类所有对象的该方法都会被上锁（也很容易理解，静态方法是类级共享的）。

synchronized在早期给人的印象就是重量级锁，开销很大。因为它用到了操作系统底层的互斥锁，涉及到用户/内核态切换。但是Java新版本也有做一些改进：
- **锁粗化**：把多个连续的加锁解锁块合并为一个临界代码块。比如连续的字符串append
- **锁消除**：如果某个数据对象被认为是不会共享的，就不会对它上锁，比如一个函数内的局部变量，每个线程都是不同的，不会互相访问，就不会上锁
- **轻量级锁**：用<font color="red">CAS原子指令</font>代替重量级锁。<font color="red">CAS</font>就是compare and swap，线程将一个读取一个数据的值A，进行操作得到C，写回之前将A和原来的数据值比较，如果相同就写回C，不同就自旋反复尝试。
- **偏向锁**：通俗来说，偏向锁也是类似于82原则，一个被共享的的数据有80%的时间都在被同一个线程t1访问，只有20%的时间被其他线程访问。所以偏向锁就会给t1一个偏向锁认证，免去它访问时的CAS操作，只有当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。

##### ReentrantLock
ReentrantLock就是可重入锁，一个线程获取到锁后，如果重复获取锁，不会被锁阻塞。重复获取n次锁，就要重复释放n次锁。

一般的使用方式
```java
       Lock lock = new ReentrantLock();
       lock.lock();
       try{
           // 代码

       }catch (Exception e){
           e.printStackTrace();
       } finally {
           lock.unlock();
       }

```