---
title: 基础知识复习笔记5-内存管理
header_image: /intro/post-bg.jpg
abstract: Java和C++的
categories: 学习
tags:
  - 笔记
abbrlink: a2044ae4
date: 2024-02-17 21:33:08
---

### C++的程序内存布局
从上往下是：
- 内核空间：操作系统内核
- 环境变量，命令行参数
- 栈（高地址向低地址增长）：存放局部变量，函数参数，返回地址等，由编译器管理
- （空闲区域）
- 堆（低地址向高地址增长）：由程序员new/delete管理，容量远大于栈
- BSS段：未初始化的数据
- data段：已初始化的数据，全局变量，静态变量
- text段：代码区

#### 智能指针
C++没有垃圾回收机制，只能由程序员手动管理内存，一旦操作不当就可能导致：
- 内存泄漏：某段代码每次执行都会申请一小段内存，结束后却不释放，久而久之就会吞噬系统的空闲内存，最终导致程序甚至系统崩溃。
  - 如果一段程序随着时间运行，内存占用越来越大且没有饱和的趋势，可能就出现了内存泄漏。
  - 内存泄漏的静态检测方法，首先就是对代码进行检查，看是否有new/delete不匹配的地方。
  - 也可以用工具进行检查，比如valgrind可以检查程序是否有非法使用内存的问题。

另外一个方法是使用智能指针，智能指针会管理对象的生命周期，在其生命周期结束时自动释放内存。
- shared_ptr：可以允许多个指针指向一个对象，通过引用计数管理对象生命周期。
- unique_ptr：对象只能由一个指针独享，可以移动对象所有权，但不能复制。
- weak_ptr：主要避免shared_ptr造成的循环引用，A引用B，B引用A，这样谁都无法被释放。weak_ptr可以提供某个对象的访问，但是不会参与引用计数。需要用时，使用lock方法来获得一个shared_ptr对象。

#### C++类的内存布局
对于一般的类，所有非静态成员变量按照声明顺序，内存对齐原则放在一起。静态成员变量放在全局数据区，所有类成员函数是放在代码区，位置没有明显关联。

有虚函数的类，类的地址起始位置有一个虚函数指针，指向虚函数表，虚函数表中存放了所有虚函数的入口地址。紧接着放非静态成员变量。子类在构造时也会有一个虚函数表，如果子类重写了虚函数，则会用新的函数地址覆盖掉表中原来的虚函数地址。

继承的话，继承类先按照其继承的基类的顺序，存放了各个基类的成员变量和各自的虚函数表指针，再存放自己的数据成员。

基类析构函数声明为虚函数：这样才能在基类指针调用析构时，执行子类的析构函数，不然可能出现局部释放的情况，只释放了基类的相关内容，子类的却没有释放，造成内存泄漏。

### Java的内存管理
Java有垃圾回收机制，不需要程序员手动管理内存分配和释放，

#### Java的垃圾回收策略
根据JVM实现的不同，策略也有所不同。Java的堆内存区域一般可以分为新生代、老年代和永久代三块，新生代一般是生命周期比较短的对象，老年代是占用内存比较大，生命周期较长的对象，永久代则是始终不会被清理的对象。

分配内存时，优先在新生代区域分配，如果内存不够，则尝试将新生代的部分对象转移到老年代。如果分配的对象很大，则会直接进入到老年代，减少垃圾回收的频率和成本。每个对象都有一个年龄计数器，每次垃圾回收没有被清理的对象年龄就会增加，增加到一定数值就会转移到老年代区域。

#### 判断对象生命周期
- 引用计数：类似于C++的shared_ptr，但是也有循环引用的问题，使用的比较少。
- 可达性分析算法：从以下对象中选择根对象，搜索根对象引用的对象，如果一个对象没有一条到达根对象的引用链，就说明它该被回收了。（我理解的就是从“钉子户”开始链式搜索，因为“钉子户”引用的对象一定是被需要的）
  - 虚拟机栈(栈帧中的局部变量表)中引用的对象
  - 本地方法栈(Native 方法)中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 所有被同步锁持有的对象
  - JNI（Java Native Interface）引用的对象

#### 垃圾收集算法
- 标记-清除算法：标记所有不用的对象，然后再依次清除。
  - 简单，但是容易产生内存碎片，标记和清除的效率低
- 复制算法：将内存划为两半，只用其中一半存放对象。内存满后，将还存活的对象复制到另一边，直接清除掉当前这边的内存。
  - 清除的效率更高，但可用内存变小了，且不适用于老年代对象，因为复制开销大
- 标记-整理算法：标记所有存活的对象，将他们向内存的一端整理移动，然后清除掉另一端的内存。
  - 整理的效率比较低

##### 分代算法
新生代使用复制算法，因为新生代的对象存活概率低，大概率不需要复制很多内容。
老年代使用标记整理算法，老年代的对象通常比较大。

